/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/async-mutex/lib/Mutex.js":
/*!***********************************************!*\
  !*** ./node_modules/async-mutex/lib/Mutex.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nvar Semaphore_1 = __webpack_require__(/*! ./Semaphore */ \"./node_modules/async-mutex/lib/Semaphore.js\");\nvar Mutex = /** @class */ (function () {\n    function Mutex(cancelError) {\n        this._semaphore = new Semaphore_1.default(1, cancelError);\n    }\n    Mutex.prototype.acquire = function () {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {\n            var _a, releaser;\n            return (0, tslib_1.__generator)(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, this._semaphore.acquire()];\n                    case 1:\n                        _a = _b.sent(), releaser = _a[1];\n                        return [2 /*return*/, releaser];\n                }\n            });\n        });\n    };\n    Mutex.prototype.runExclusive = function (callback) {\n        return this._semaphore.runExclusive(function () { return callback(); });\n    };\n    Mutex.prototype.isLocked = function () {\n        return this._semaphore.isLocked();\n    };\n    Mutex.prototype.waitForUnlock = function () {\n        return this._semaphore.waitForUnlock();\n    };\n    /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n    Mutex.prototype.release = function () {\n        this._semaphore.release();\n    };\n    Mutex.prototype.cancel = function () {\n        return this._semaphore.cancel();\n    };\n    return Mutex;\n}());\nexports[\"default\"] = Mutex;\n\n\n//# sourceURL=webpack:///./node_modules/async-mutex/lib/Mutex.js?");

/***/ }),

/***/ "./node_modules/async-mutex/lib/Semaphore.js":
/*!***************************************************!*\
  !*** ./node_modules/async-mutex/lib/Semaphore.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nvar errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/async-mutex/lib/errors.js\");\nvar Semaphore = /** @class */ (function () {\n    function Semaphore(_maxConcurrency, _cancelError) {\n        if (_cancelError === void 0) { _cancelError = errors_1.E_CANCELED; }\n        this._maxConcurrency = _maxConcurrency;\n        this._cancelError = _cancelError;\n        this._queue = [];\n        this._waiters = [];\n        if (_maxConcurrency <= 0) {\n            throw new Error('semaphore must be initialized to a positive value');\n        }\n        this._value = _maxConcurrency;\n    }\n    Semaphore.prototype.acquire = function () {\n        var _this = this;\n        var locked = this.isLocked();\n        var ticketPromise = new Promise(function (resolve, reject) {\n            return _this._queue.push({ resolve: resolve, reject: reject });\n        });\n        if (!locked)\n            this._dispatch();\n        return ticketPromise;\n    };\n    Semaphore.prototype.runExclusive = function (callback) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {\n            var _a, value, release;\n            return (0, tslib_1.__generator)(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, this.acquire()];\n                    case 1:\n                        _a = _b.sent(), value = _a[0], release = _a[1];\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, , 4, 5]);\n                        return [4 /*yield*/, callback(value)];\n                    case 3: return [2 /*return*/, _b.sent()];\n                    case 4:\n                        release();\n                        return [7 /*endfinally*/];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Semaphore.prototype.waitForUnlock = function () {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {\n            var waitPromise;\n            var _this = this;\n            return (0, tslib_1.__generator)(this, function (_a) {\n                if (!this.isLocked()) {\n                    return [2 /*return*/, Promise.resolve()];\n                }\n                waitPromise = new Promise(function (resolve) { return _this._waiters.push({ resolve: resolve }); });\n                return [2 /*return*/, waitPromise];\n            });\n        });\n    };\n    Semaphore.prototype.isLocked = function () {\n        return this._value <= 0;\n    };\n    /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n    Semaphore.prototype.release = function () {\n        if (this._maxConcurrency > 1) {\n            throw new Error('this method is unavailable on semaphores with concurrency > 1; use the scoped release returned by acquire instead');\n        }\n        if (this._currentReleaser) {\n            var releaser = this._currentReleaser;\n            this._currentReleaser = undefined;\n            releaser();\n        }\n    };\n    Semaphore.prototype.cancel = function () {\n        var _this = this;\n        this._queue.forEach(function (ticket) { return ticket.reject(_this._cancelError); });\n        this._queue = [];\n    };\n    Semaphore.prototype._dispatch = function () {\n        var _this = this;\n        var nextTicket = this._queue.shift();\n        if (!nextTicket)\n            return;\n        var released = false;\n        this._currentReleaser = function () {\n            if (released)\n                return;\n            released = true;\n            _this._value++;\n            _this._resolveWaiters();\n            _this._dispatch();\n        };\n        nextTicket.resolve([this._value--, this._currentReleaser]);\n    };\n    Semaphore.prototype._resolveWaiters = function () {\n        this._waiters.forEach(function (waiter) { return waiter.resolve(); });\n        this._waiters = [];\n    };\n    return Semaphore;\n}());\nexports[\"default\"] = Semaphore;\n\n\n//# sourceURL=webpack:///./node_modules/async-mutex/lib/Semaphore.js?");

/***/ }),

/***/ "./node_modules/async-mutex/lib/errors.js":
/*!************************************************!*\
  !*** ./node_modules/async-mutex/lib/errors.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.E_CANCELED = exports.E_ALREADY_LOCKED = exports.E_TIMEOUT = void 0;\nexports.E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nexports.E_ALREADY_LOCKED = new Error('mutex already locked');\nexports.E_CANCELED = new Error('request for lock canceled');\n\n\n//# sourceURL=webpack:///./node_modules/async-mutex/lib/errors.js?");

/***/ }),

/***/ "./node_modules/async-mutex/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/async-mutex/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.tryAcquire = exports.withTimeout = exports.Semaphore = exports.Mutex = void 0;\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nvar Mutex_1 = __webpack_require__(/*! ./Mutex */ \"./node_modules/async-mutex/lib/Mutex.js\");\nObject.defineProperty(exports, \"Mutex\", ({ enumerable: true, get: function () { return Mutex_1.default; } }));\nvar Semaphore_1 = __webpack_require__(/*! ./Semaphore */ \"./node_modules/async-mutex/lib/Semaphore.js\");\nObject.defineProperty(exports, \"Semaphore\", ({ enumerable: true, get: function () { return Semaphore_1.default; } }));\nvar withTimeout_1 = __webpack_require__(/*! ./withTimeout */ \"./node_modules/async-mutex/lib/withTimeout.js\");\nObject.defineProperty(exports, \"withTimeout\", ({ enumerable: true, get: function () { return withTimeout_1.withTimeout; } }));\nvar tryAcquire_1 = __webpack_require__(/*! ./tryAcquire */ \"./node_modules/async-mutex/lib/tryAcquire.js\");\nObject.defineProperty(exports, \"tryAcquire\", ({ enumerable: true, get: function () { return tryAcquire_1.tryAcquire; } }));\n(0, tslib_1.__exportStar)(__webpack_require__(/*! ./errors */ \"./node_modules/async-mutex/lib/errors.js\"), exports);\n\n\n//# sourceURL=webpack:///./node_modules/async-mutex/lib/index.js?");

/***/ }),

/***/ "./node_modules/async-mutex/lib/tryAcquire.js":
/*!****************************************************!*\
  !*** ./node_modules/async-mutex/lib/tryAcquire.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.tryAcquire = void 0;\nvar errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/async-mutex/lib/errors.js\");\nvar withTimeout_1 = __webpack_require__(/*! ./withTimeout */ \"./node_modules/async-mutex/lib/withTimeout.js\");\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError) {\n    if (alreadyAcquiredError === void 0) { alreadyAcquiredError = errors_1.E_ALREADY_LOCKED; }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (0, withTimeout_1.withTimeout)(sync, 0, alreadyAcquiredError);\n}\nexports.tryAcquire = tryAcquire;\n\n\n//# sourceURL=webpack:///./node_modules/async-mutex/lib/tryAcquire.js?");

/***/ }),

/***/ "./node_modules/async-mutex/lib/withTimeout.js":
/*!*****************************************************!*\
  !*** ./node_modules/async-mutex/lib/withTimeout.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.withTimeout = void 0;\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nvar errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/async-mutex/lib/errors.js\");\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction withTimeout(sync, timeout, timeoutError) {\n    var _this = this;\n    if (timeoutError === void 0) { timeoutError = errors_1.E_TIMEOUT; }\n    return {\n        acquire: function () {\n            return new Promise(function (resolve, reject) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {\n                var isTimeout, handle, ticket, release, e_1;\n                return (0, tslib_1.__generator)(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            isTimeout = false;\n                            handle = setTimeout(function () {\n                                isTimeout = true;\n                                reject(timeoutError);\n                            }, timeout);\n                            _a.label = 1;\n                        case 1:\n                            _a.trys.push([1, 3, , 4]);\n                            return [4 /*yield*/, sync.acquire()];\n                        case 2:\n                            ticket = _a.sent();\n                            if (isTimeout) {\n                                release = Array.isArray(ticket) ? ticket[1] : ticket;\n                                release();\n                            }\n                            else {\n                                clearTimeout(handle);\n                                resolve(ticket);\n                            }\n                            return [3 /*break*/, 4];\n                        case 3:\n                            e_1 = _a.sent();\n                            if (!isTimeout) {\n                                clearTimeout(handle);\n                                reject(e_1);\n                            }\n                            return [3 /*break*/, 4];\n                        case 4: return [2 /*return*/];\n                    }\n                });\n            }); });\n        },\n        runExclusive: function (callback) {\n            return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {\n                var release, ticket;\n                return (0, tslib_1.__generator)(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            release = function () { return undefined; };\n                            _a.label = 1;\n                        case 1:\n                            _a.trys.push([1, , 7, 8]);\n                            return [4 /*yield*/, this.acquire()];\n                        case 2:\n                            ticket = _a.sent();\n                            if (!Array.isArray(ticket)) return [3 /*break*/, 4];\n                            release = ticket[1];\n                            return [4 /*yield*/, callback(ticket[0])];\n                        case 3: return [2 /*return*/, _a.sent()];\n                        case 4:\n                            release = ticket;\n                            return [4 /*yield*/, callback()];\n                        case 5: return [2 /*return*/, _a.sent()];\n                        case 6: return [3 /*break*/, 8];\n                        case 7:\n                            release();\n                            return [7 /*endfinally*/];\n                        case 8: return [2 /*return*/];\n                    }\n                });\n            });\n        },\n        /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n        release: function () {\n            sync.release();\n        },\n        cancel: function () {\n            return sync.cancel();\n        },\n        waitForUnlock: function () { return sync.waitForUnlock(); },\n        isLocked: function () { return sync.isLocked(); },\n    };\n}\nexports.withTimeout = withTimeout;\n\n\n//# sourceURL=webpack:///./node_modules/async-mutex/lib/withTimeout.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst z3 = __webpack_require__(/*! z3-solver */ \"./node_modules/z3-solver/build/browser.js\");\nconst setup_1 = __webpack_require__(/*! ./setup */ \"./setup.ts\");\nconst inputGrid = Array.from(Array(9), () => new Array(9));\nfor (let i = 0; i < 9; i++) {\n    for (let j = 0; j < 9; j++) {\n        inputGrid[i][j] = document.getElementById(`i${i}${j}`);\n    }\n}\nfunction getGrid() {\n    const grid = Array.from(Array(9), () => new Array(9));\n    for (let i = 0; i < 9; i++) {\n        for (let j = 0; j < 9; j++) {\n            grid[i][j] = parseInt(inputGrid[i][j].value);\n        }\n    }\n    return grid;\n}\n// Grabs the constraints div and gets the id's of all checked children inputs \nfunction getConstraints() {\n    var _a, _b;\n    let out = [];\n    (_b = (_a = document.getElementById(\"constraints\")) === null || _a === void 0 ? void 0 : _a.querySelectorAll(\"input\")) === null || _b === void 0 ? void 0 : _b.forEach(child => {\n        if (child.checked)\n            out.push(child.id);\n    });\n    (0, setup_1.default)();\n    return out;\n}\nwindow.z3Promise = z3.init();\n// so other scripts can Z3 - they just need to `await window.z3Promise`\n// this script must be before those scripts on the page\nlet runBtn = document.getElementById(\"run\");\nif (runBtn === undefined || runBtn === null) {\n    console.error(\"no run btn\");\n}\nelse {\n    runBtn.addEventListener(\"click\", async () => {\n        console.log(getConstraints());\n        const sudokuGrid = getGrid();\n        console.log(sudokuGrid);\n        let { Context } = await window.z3Promise;\n        let { Solver, Int, Distinct } = Context(\"main\");\n        let solver = new Solver();\n        let z3Grid = Array.from(Array(9), () => new Array(9));\n        for (let i = 0; i < 9; i++) {\n            for (let j = 0; j < 9; j++) {\n                z3Grid[i][j] = Int.const(`x_${i}${j}`);\n                if (1 <= sudokuGrid[i][j] && sudokuGrid[i][j] <= 9) {\n                    solver.add(z3Grid[i][j].eq(sudokuGrid[i][j]));\n                }\n                else {\n                    solver.add(z3Grid[i][j].ge(1).and(z3Grid[i][j].le(9)));\n                }\n            }\n        }\n        // 1-9horiz\n        for (let i = 0; i < 9; i++) {\n            solver.add(Distinct(...z3Grid[i]));\n        }\n        // 1-9vert\n        for (let i = 0; i < 9; i++) {\n            solver.add(Distinct(...z3Grid.map(row => row[i])));\n        }\n        // 1-9nonet\n        // you could also probably use distinct here too but idk\n        for (let i = 0; i < 9; i++) {\n            for (let j = 0; j < 9; j++) {\n                for (let k = j + 1; k < 9; k++) {\n                    let i_0 = (Math.floor(i / 3) * 3) + Math.floor(j / 3);\n                    let j_0 = ((i % 3) * 3) + (j % 3);\n                    let i_1 = (Math.floor(i / 3) * 3) + Math.floor(k / 3);\n                    let j_1 = ((i % 3) * 3) + (k % 3);\n                    solver.add(z3Grid[i_0][j_0].neq(z3Grid[i_1][j_1]));\n                }\n            }\n        }\n        console.log(await solver.check());\n        const resultGrid = Array.from(Array(9), () => new Array(9));\n        for (let i = 0; i < 9; i++) {\n            for (let j = 0; j < 9; j++) {\n                // i hate this parseInt weirdness but idk how to get an integer directly\n                resultGrid[i][j] = parseInt(solver.model().get(z3Grid[i][j]).toString());\n            }\n        }\n        console.log(resultGrid);\n    });\n}\n\n\n//# sourceURL=webpack:///./index.ts?");

/***/ }),

/***/ "./setup.ts":
/*!******************!*\
  !*** ./setup.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction hi() {\n    console.log(\"Hi\");\n}\nexports[\"default\"] = hi;\n\n\n//# sourceURL=webpack:///./setup.ts?");

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__assign\": () => (/* binding */ __assign),\n/* harmony export */   \"__asyncDelegator\": () => (/* binding */ __asyncDelegator),\n/* harmony export */   \"__asyncGenerator\": () => (/* binding */ __asyncGenerator),\n/* harmony export */   \"__asyncValues\": () => (/* binding */ __asyncValues),\n/* harmony export */   \"__await\": () => (/* binding */ __await),\n/* harmony export */   \"__awaiter\": () => (/* binding */ __awaiter),\n/* harmony export */   \"__classPrivateFieldGet\": () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   \"__classPrivateFieldIn\": () => (/* binding */ __classPrivateFieldIn),\n/* harmony export */   \"__classPrivateFieldSet\": () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   \"__createBinding\": () => (/* binding */ __createBinding),\n/* harmony export */   \"__decorate\": () => (/* binding */ __decorate),\n/* harmony export */   \"__exportStar\": () => (/* binding */ __exportStar),\n/* harmony export */   \"__extends\": () => (/* binding */ __extends),\n/* harmony export */   \"__generator\": () => (/* binding */ __generator),\n/* harmony export */   \"__importDefault\": () => (/* binding */ __importDefault),\n/* harmony export */   \"__importStar\": () => (/* binding */ __importStar),\n/* harmony export */   \"__makeTemplateObject\": () => (/* binding */ __makeTemplateObject),\n/* harmony export */   \"__metadata\": () => (/* binding */ __metadata),\n/* harmony export */   \"__param\": () => (/* binding */ __param),\n/* harmony export */   \"__read\": () => (/* binding */ __read),\n/* harmony export */   \"__rest\": () => (/* binding */ __rest),\n/* harmony export */   \"__spread\": () => (/* binding */ __spread),\n/* harmony export */   \"__spreadArray\": () => (/* binding */ __spreadArray),\n/* harmony export */   \"__spreadArrays\": () => (/* binding */ __spreadArrays),\n/* harmony export */   \"__values\": () => (/* binding */ __values)\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nfunction __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/tslib/tslib.es6.js?");

/***/ }),

/***/ "./node_modules/z3-solver/build/browser.js":
/*!*************************************************!*\
  !*** ./node_modules/z3-solver/build/browser.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nconst high_level_1 = __webpack_require__(/*! ./high-level */ \"./node_modules/z3-solver/build/high-level/index.js\");\nconst low_level_1 = __webpack_require__(/*! ./low-level */ \"./node_modules/z3-solver/build/low-level/index.js\");\n__exportStar(__webpack_require__(/*! ./high-level/types */ \"./node_modules/z3-solver/build/high-level/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./low-level/types.__GENERATED__ */ \"./node_modules/z3-solver/build/low-level/types.__GENERATED__.js\"), exports);\nasync function init() {\n    const initZ3 = __webpack_require__.g.initZ3;\n    if (initZ3 === undefined) {\n        throw new Error('initZ3 was not imported correctly. Please consult documentation on how to load Z3 in browser');\n    }\n    const lowLevel = await (0, low_level_1.init)(initZ3);\n    const highLevel = (0, high_level_1.createApi)(lowLevel.Z3);\n    return { ...lowLevel, ...highLevel };\n}\nexports.init = init;\n\n\n//# sourceURL=webpack:///./node_modules/z3-solver/build/browser.js?");

/***/ }),

/***/ "./node_modules/z3-solver/build/high-level/high-level.js":
/*!***************************************************************!*\
  !*** ./node_modules/z3-solver/build/high-level/high-level.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createApi = void 0;\n// TODO(ritave): Add typing for Context Options\n//               https://github.com/Z3Prover/z3/pull/6048#discussion_r883391669\n// TODO(ritave): Add an error handler\n// TODO(ritave): Add support for building faster floats without support for Safari\n// TODO(ritave): Use Z3_DECLARE_CLOSURE macro to generate code https://github.com/Z3Prover/z3/pull/6048#discussion_r884155462\n// TODO(ritave): Add pretty printing\n// TODO(ritave): Make Z3 multi-threaded\n// TODO(ritave): If a test times out, jest kills it, and the global state of Z3 is left in an unexpected state.\n//               This occurs specifically during longer check(). Afterwards, all next tests will fail to run\n//               thinking the previous call was not finished. Find a way to stop execution and clean up the global state\nconst async_mutex_1 = __webpack_require__(/*! async-mutex */ \"./node_modules/async-mutex/lib/index.js\");\nconst low_level_1 = __webpack_require__(/*! ../low-level */ \"./node_modules/z3-solver/build/low-level/index.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/z3-solver/build/high-level/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/z3-solver/build/high-level/utils.js\");\nconst FALLBACK_PRECISION = 17;\nconst asyncMutex = new async_mutex_1.Mutex();\nfunction isCoercibleRational(obj) {\n    // prettier-ignore\n    const r = ((obj !== null &&\n        (typeof obj === 'object' || typeof obj === 'function')) &&\n        (obj.numerator !== null &&\n            (typeof obj.numerator === 'number' || typeof obj.numerator === 'bigint')) &&\n        (obj.denominator !== null &&\n            (typeof obj.denominator === 'number' || typeof obj.denominator === 'bigint')));\n    r &&\n        (0, utils_1.assert)((typeof obj.numerator !== 'number' || Number.isSafeInteger(obj.numerator)) &&\n            (typeof obj.denominator !== 'number' || Number.isSafeInteger(obj.denominator)), 'Fraction numerator and denominator must be integers');\n    return r;\n}\nfunction createApi(Z3) {\n    // TODO(ritave): Create a custom linting rule that checks if the provided callbacks to cleanup\n    //               Don't capture `this`\n    const cleanup = new FinalizationRegistry(callback => callback());\n    function enableTrace(tag) {\n        Z3.enable_trace(tag);\n    }\n    function disableTrace(tag) {\n        Z3.disable_trace(tag);\n    }\n    function getVersion() {\n        return Z3.get_version();\n    }\n    function getVersionString() {\n        const { major, minor, build_number } = Z3.get_version();\n        return `${major}.${minor}.${build_number}`;\n    }\n    function getFullVersion() {\n        return Z3.get_full_version();\n    }\n    function openLog(filename) {\n        return Z3.open_log(filename);\n    }\n    function appendLog(s) {\n        Z3.append_log(s);\n    }\n    function setParam(key, value) {\n        if (typeof key === 'string') {\n            Z3.global_param_set(key, value.toString());\n        }\n        else {\n            (0, utils_1.assert)(value === undefined, \"Can't provide a Record and second parameter to set_param at the same time\");\n            Object.entries(key).forEach(([key, value]) => setParam(key, value));\n        }\n    }\n    function resetParams() {\n        Z3.global_param_reset_all();\n    }\n    function getParam(name) {\n        return Z3.global_param_get(name);\n    }\n    function createContext(name, options) {\n        const cfg = Z3.mk_config();\n        if (options != null) {\n            Object.entries(options).forEach(([key, value]) => check(Z3.set_param_value(cfg, key, value.toString())));\n        }\n        const contextPtr = Z3.mk_context_rc(cfg);\n        Z3.set_ast_print_mode(contextPtr, low_level_1.Z3_ast_print_mode.Z3_PRINT_SMTLIB2_COMPLIANT);\n        Z3.del_config(cfg);\n        function _assertContext(...ctxs) {\n            ctxs.forEach(other => (0, utils_1.assert)('ctx' in other ? ctx === other.ctx : ctx === other, 'Context mismatch'));\n        }\n        // call this after every nontrivial call to the underlying API\n        function throwIfError() {\n            if (Z3.get_error_code(contextPtr) !== low_level_1.Z3_error_code.Z3_OK) {\n                throw new Error(Z3.get_error_msg(ctx.ptr, Z3.get_error_code(ctx.ptr)));\n            }\n        }\n        function check(val) {\n            throwIfError();\n            return val;\n        }\n        /////////////\n        // Private //\n        /////////////\n        function _toSymbol(s) {\n            if (typeof s === 'number') {\n                return check(Z3.mk_int_symbol(contextPtr, s));\n            }\n            else {\n                return check(Z3.mk_string_symbol(contextPtr, s));\n            }\n        }\n        function _fromSymbol(sym) {\n            const kind = check(Z3.get_symbol_kind(contextPtr, sym));\n            switch (kind) {\n                case low_level_1.Z3_symbol_kind.Z3_INT_SYMBOL:\n                    return Z3.get_symbol_int(contextPtr, sym);\n                case low_level_1.Z3_symbol_kind.Z3_STRING_SYMBOL:\n                    return Z3.get_symbol_string(contextPtr, sym);\n                default:\n                    (0, utils_1.assertExhaustive)(kind);\n            }\n        }\n        function _toAst(ast) {\n            switch (check(Z3.get_ast_kind(contextPtr, ast))) {\n                case low_level_1.Z3_ast_kind.Z3_SORT_AST:\n                    return _toSort(ast);\n                case low_level_1.Z3_ast_kind.Z3_FUNC_DECL_AST:\n                    return new FuncDeclImpl(ast);\n                default:\n                    return _toExpr(ast);\n            }\n        }\n        function _toSort(ast) {\n            switch (check(Z3.get_sort_kind(contextPtr, ast))) {\n                case low_level_1.Z3_sort_kind.Z3_BOOL_SORT:\n                    return new BoolSortImpl(ast);\n                case low_level_1.Z3_sort_kind.Z3_INT_SORT:\n                case low_level_1.Z3_sort_kind.Z3_REAL_SORT:\n                    return new ArithSortImpl(ast);\n                case low_level_1.Z3_sort_kind.Z3_BV_SORT:\n                    return new BitVecSortImpl(ast);\n                default:\n                    return new SortImpl(ast);\n            }\n        }\n        function _toExpr(ast) {\n            const kind = check(Z3.get_ast_kind(contextPtr, ast));\n            if (kind === low_level_1.Z3_ast_kind.Z3_QUANTIFIER_AST) {\n                (0, utils_1.assert)(false);\n            }\n            const sortKind = check(Z3.get_sort_kind(contextPtr, Z3.get_sort(contextPtr, ast)));\n            switch (sortKind) {\n                case low_level_1.Z3_sort_kind.Z3_BOOL_SORT:\n                    return new BoolImpl(ast);\n                case low_level_1.Z3_sort_kind.Z3_INT_SORT:\n                    if (kind === low_level_1.Z3_ast_kind.Z3_NUMERAL_AST) {\n                        return new IntNumImpl(ast);\n                    }\n                    return new ArithImpl(ast);\n                case low_level_1.Z3_sort_kind.Z3_REAL_SORT:\n                    if (kind === low_level_1.Z3_ast_kind.Z3_NUMERAL_AST) {\n                        return new RatNumImpl(ast);\n                    }\n                    return new ArithImpl(ast);\n                case low_level_1.Z3_sort_kind.Z3_BV_SORT:\n                    if (kind === low_level_1.Z3_ast_kind.Z3_NUMERAL_AST) {\n                        return new BitVecNumImpl(ast);\n                    }\n                    return new BitVecImpl(ast);\n                default:\n                    return new ExprImpl(ast);\n            }\n        }\n        function _flattenArgs(args) {\n            const result = [];\n            for (const arg of args) {\n                if (isAstVector(arg)) {\n                    result.push(...arg.values());\n                }\n                else {\n                    result.push(arg);\n                }\n            }\n            return result;\n        }\n        function _toProbe(p) {\n            if (isProbe(p)) {\n                return p;\n            }\n            return new ProbeImpl(p);\n        }\n        function _probeNary(f, args) {\n            (0, utils_1.assert)(args.length > 0, 'At least one argument expected');\n            let r = _toProbe(args[0]);\n            for (let i = 1; i < args.length; i++) {\n                r = new ProbeImpl(check(f(contextPtr, r.ptr, _toProbe(args[i]).ptr)));\n            }\n            return r;\n        }\n        ///////////////\n        // Functions //\n        ///////////////\n        function interrupt() {\n            check(Z3.interrupt(contextPtr));\n        }\n        function isModel(obj) {\n            const r = obj instanceof ModelImpl;\n            r && _assertContext(obj);\n            return r;\n        }\n        function isAst(obj) {\n            const r = obj instanceof AstImpl;\n            r && _assertContext(obj);\n            return r;\n        }\n        function isSort(obj) {\n            const r = obj instanceof SortImpl;\n            r && _assertContext(obj);\n            return r;\n        }\n        function isFuncDecl(obj) {\n            const r = obj instanceof FuncDeclImpl;\n            r && _assertContext(obj);\n            return r;\n        }\n        function isApp(obj) {\n            if (!isExpr(obj)) {\n                return false;\n            }\n            const kind = check(Z3.get_ast_kind(contextPtr, obj.ast));\n            return kind === low_level_1.Z3_ast_kind.Z3_NUMERAL_AST || kind === low_level_1.Z3_ast_kind.Z3_APP_AST;\n        }\n        function isConst(obj) {\n            return isExpr(obj) && isApp(obj) && obj.numArgs() === 0;\n        }\n        function isExpr(obj) {\n            const r = obj instanceof ExprImpl;\n            r && _assertContext(obj);\n            return r;\n        }\n        function isVar(obj) {\n            return isExpr(obj) && check(Z3.get_ast_kind(contextPtr, obj.ast)) === low_level_1.Z3_ast_kind.Z3_VAR_AST;\n        }\n        function isAppOf(obj, kind) {\n            return isExpr(obj) && isApp(obj) && obj.decl().kind() === kind;\n        }\n        function isBool(obj) {\n            const r = obj instanceof BoolImpl;\n            r && _assertContext(obj);\n            return r;\n        }\n        function isTrue(obj) {\n            return isAppOf(obj, low_level_1.Z3_decl_kind.Z3_OP_TRUE);\n        }\n        function isFalse(obj) {\n            return isAppOf(obj, low_level_1.Z3_decl_kind.Z3_OP_FALSE);\n        }\n        function isAnd(obj) {\n            return isAppOf(obj, low_level_1.Z3_decl_kind.Z3_OP_AND);\n        }\n        function isOr(obj) {\n            return isAppOf(obj, low_level_1.Z3_decl_kind.Z3_OP_OR);\n        }\n        function isImplies(obj) {\n            return isAppOf(obj, low_level_1.Z3_decl_kind.Z3_OP_IMPLIES);\n        }\n        function isNot(obj) {\n            return isAppOf(obj, low_level_1.Z3_decl_kind.Z3_OP_NOT);\n        }\n        function isEq(obj) {\n            return isAppOf(obj, low_level_1.Z3_decl_kind.Z3_OP_EQ);\n        }\n        function isDistinct(obj) {\n            return isAppOf(obj, low_level_1.Z3_decl_kind.Z3_OP_DISTINCT);\n        }\n        function isArith(obj) {\n            const r = obj instanceof ArithImpl;\n            r && _assertContext(obj);\n            return r;\n        }\n        function isArithSort(obj) {\n            const r = obj instanceof ArithSortImpl;\n            r && _assertContext(obj);\n            return r;\n        }\n        function isInt(obj) {\n            return isArith(obj) && isIntSort(obj.sort);\n        }\n        function isIntVal(obj) {\n            const r = obj instanceof IntNumImpl;\n            r && _assertContext(obj);\n            return r;\n        }\n        function isIntSort(obj) {\n            return isSort(obj) && obj.kind() === low_level_1.Z3_sort_kind.Z3_INT_SORT;\n        }\n        function isReal(obj) {\n            return isArith(obj) && isRealSort(obj.sort);\n        }\n        function isRealVal(obj) {\n            const r = obj instanceof RatNumImpl;\n            r && _assertContext(obj);\n            return r;\n        }\n        function isRealSort(obj) {\n            return isSort(obj) && obj.kind() === low_level_1.Z3_sort_kind.Z3_REAL_SORT;\n        }\n        function isBitVecSort(obj) {\n            const r = obj instanceof BitVecSortImpl;\n            r && _assertContext(obj);\n            return r;\n        }\n        function isBitVec(obj) {\n            const r = obj instanceof BitVecImpl;\n            r && _assertContext(obj);\n            return r;\n        }\n        function isBitVecVal(obj) {\n            const r = obj instanceof BitVecNumImpl;\n            r && _assertContext(obj);\n            return r;\n        }\n        function isProbe(obj) {\n            const r = obj instanceof ProbeImpl;\n            r && _assertContext(obj);\n            return r;\n        }\n        function isTactic(obj) {\n            const r = obj instanceof TacticImpl;\n            r && _assertContext(obj);\n            return r;\n        }\n        function isAstVector(obj) {\n            const r = obj instanceof AstVectorImpl;\n            r && _assertContext(obj);\n            return r;\n        }\n        function eqIdentity(a, b) {\n            return a.eqIdentity(b);\n        }\n        function getVarIndex(obj) {\n            (0, utils_1.assert)(isVar(obj), 'Z3 bound variable expected');\n            return Z3.get_index_value(contextPtr, obj.ast);\n        }\n        function from(value) {\n            if (typeof value === 'boolean') {\n                return Bool.val(value);\n            }\n            else if (typeof value === 'number') {\n                if (!Number.isFinite(value)) {\n                    throw new Error(`cannot represent infinity/NaN (got ${value})`);\n                }\n                if (Math.floor(value) === value) {\n                    return Int.val(value);\n                }\n                return Real.val(value);\n            }\n            else if (isCoercibleRational(value)) {\n                return Real.val(value);\n            }\n            else if (typeof value === 'bigint') {\n                return Int.val(value);\n            }\n            else if (isExpr(value)) {\n                return value;\n            }\n            (0, utils_1.assert)(false);\n        }\n        async function solve(...assertions) {\n            const solver = new ctx.Solver();\n            solver.add(...assertions);\n            const result = await solver.check();\n            if (result === 'sat') {\n                return solver.model();\n            }\n            return result;\n        }\n        /////////////\n        // Objects //\n        /////////////\n        const Sort = {\n            declare: (name) => new SortImpl(Z3.mk_uninterpreted_sort(contextPtr, _toSymbol(name))),\n        };\n        const Function = {\n            declare: (name, ...signature) => {\n                const arity = signature.length - 1;\n                const rng = signature[arity];\n                _assertContext(rng);\n                const dom = [];\n                for (let i = 0; i < arity; i++) {\n                    _assertContext(signature[i]);\n                    dom.push(signature[i].ptr);\n                }\n                return new FuncDeclImpl(Z3.mk_func_decl(contextPtr, _toSymbol(name), dom, rng.ptr));\n            },\n            fresh: (...signature) => {\n                const arity = signature.length - 1;\n                const rng = signature[arity];\n                _assertContext(rng);\n                const dom = [];\n                for (let i = 0; i < arity; i++) {\n                    _assertContext(signature[i]);\n                    dom.push(signature[i].ptr);\n                }\n                return new FuncDeclImpl(Z3.mk_fresh_func_decl(contextPtr, 'f', dom, rng.ptr));\n            },\n        };\n        const RecFunc = {\n            declare: (name, ...signature) => {\n                const arity = signature.length - 1;\n                const rng = signature[arity];\n                _assertContext(rng);\n                const dom = [];\n                for (let i = 0; i < arity; i++) {\n                    _assertContext(signature[i]);\n                    dom.push(signature[i].ptr);\n                }\n                return new FuncDeclImpl(Z3.mk_rec_func_decl(contextPtr, _toSymbol(name), dom, rng.ptr));\n            },\n            addDefinition: (f, args, body) => {\n                _assertContext(f, ...args, body);\n                check(Z3.add_rec_def(contextPtr, f.ptr, args.map(arg => arg.ast), body.ast));\n            },\n        };\n        const Bool = {\n            sort: () => new BoolSortImpl(Z3.mk_bool_sort(contextPtr)),\n            const: (name) => new BoolImpl(Z3.mk_const(contextPtr, _toSymbol(name), Bool.sort().ptr)),\n            consts: (names) => {\n                if (typeof names === 'string') {\n                    names = names.split(' ');\n                }\n                return names.map(name => Bool.const(name));\n            },\n            vector: (prefix, count) => {\n                const result = [];\n                for (let i = 0; i < count; i++) {\n                    result.push(Bool.const(`${prefix}__${i}`));\n                }\n                return result;\n            },\n            fresh: (prefix = 'b') => new BoolImpl(Z3.mk_fresh_const(contextPtr, prefix, Bool.sort().ptr)),\n            val: (value) => {\n                if (value) {\n                    return new BoolImpl(Z3.mk_true(contextPtr));\n                }\n                return new BoolImpl(Z3.mk_false(contextPtr));\n            },\n        };\n        const Int = {\n            sort: () => new ArithSortImpl(Z3.mk_int_sort(contextPtr)),\n            const: (name) => new ArithImpl(Z3.mk_const(contextPtr, _toSymbol(name), Int.sort().ptr)),\n            consts: (names) => {\n                if (typeof names === 'string') {\n                    names = names.split(' ');\n                }\n                return names.map(name => Int.const(name));\n            },\n            vector: (prefix, count) => {\n                const result = [];\n                for (let i = 0; i < count; i++) {\n                    result.push(Int.const(`${prefix}__${i}`));\n                }\n                return result;\n            },\n            fresh: (prefix = 'x') => new ArithImpl(Z3.mk_fresh_const(contextPtr, prefix, Int.sort().ptr)),\n            val: (value) => {\n                (0, utils_1.assert)(typeof value === 'bigint' || typeof value === 'string' || Number.isSafeInteger(value));\n                return new IntNumImpl(check(Z3.mk_numeral(contextPtr, value.toString(), Int.sort().ptr)));\n            },\n        };\n        const Real = {\n            sort: () => new ArithSortImpl(Z3.mk_real_sort(contextPtr)),\n            const: (name) => new ArithImpl(check(Z3.mk_const(contextPtr, _toSymbol(name), Real.sort().ptr))),\n            consts: (names) => {\n                if (typeof names === 'string') {\n                    names = names.split(' ');\n                }\n                return names.map(name => Real.const(name));\n            },\n            vector: (prefix, count) => {\n                const result = [];\n                for (let i = 0; i < count; i++) {\n                    result.push(Real.const(`${prefix}__${i}`));\n                }\n                return result;\n            },\n            fresh: (prefix = 'b') => new ArithImpl(Z3.mk_fresh_const(contextPtr, prefix, Real.sort().ptr)),\n            val: (value) => {\n                if (isCoercibleRational(value)) {\n                    value = `${value.numerator}/${value.denominator}`;\n                }\n                return new RatNumImpl(Z3.mk_numeral(contextPtr, value.toString(), Real.sort().ptr));\n            },\n        };\n        const BitVec = {\n            sort(bits) {\n                (0, utils_1.assert)(Number.isSafeInteger(bits), 'number of bits must be an integer');\n                return new BitVecSortImpl(Z3.mk_bv_sort(contextPtr, bits));\n            },\n            const(name, bits) {\n                return new BitVecImpl(check(Z3.mk_const(contextPtr, _toSymbol(name), isBitVecSort(bits) ? bits.ptr : BitVec.sort(bits).ptr)));\n            },\n            consts(names, bits) {\n                if (typeof names === 'string') {\n                    names = names.split(' ');\n                }\n                return names.map(name => BitVec.const(name, bits));\n            },\n            val(value, bits) {\n                if (value === true) {\n                    return BitVec.val(1, bits);\n                }\n                else if (value === false) {\n                    return BitVec.val(0, bits);\n                }\n                return new BitVecNumImpl(check(Z3.mk_numeral(contextPtr, value.toString(), isBitVecSort(bits) ? bits.ptr : BitVec.sort(bits).ptr)));\n            },\n        };\n        function If(condition, onTrue, onFalse) {\n            if (isProbe(condition) && isTactic(onTrue) && isTactic(onFalse)) {\n                return Cond(condition, onTrue, onFalse);\n            }\n            (0, utils_1.assert)(!isProbe(condition) && !isTactic(onTrue) && !isTactic(onFalse), 'Mixed expressions and goals');\n            if (typeof condition === 'boolean') {\n                condition = Bool.val(condition);\n            }\n            onTrue = from(onTrue);\n            onFalse = from(onFalse);\n            return _toExpr(check(Z3.mk_ite(contextPtr, condition.ptr, onTrue.ast, onFalse.ast)));\n        }\n        function Distinct(...exprs) {\n            (0, utils_1.assert)(exprs.length > 0, \"Can't make Distinct ouf of nothing\");\n            return new BoolImpl(check(Z3.mk_distinct(contextPtr, exprs.map(expr => {\n                expr = from(expr);\n                _assertContext(expr);\n                return expr.ast;\n            }))));\n        }\n        function Const(name, sort) {\n            _assertContext(sort);\n            return _toExpr(check(Z3.mk_const(contextPtr, _toSymbol(name), sort.ptr)));\n        }\n        function Consts(names, sort) {\n            _assertContext(sort);\n            if (typeof names === 'string') {\n                names = names.split(' ');\n            }\n            return names.map(name => Const(name, sort));\n        }\n        function FreshConst(sort, prefix = 'c') {\n            _assertContext(sort);\n            return _toExpr(Z3.mk_fresh_const(sort.ctx.ptr, prefix, sort.ptr));\n        }\n        function Var(idx, sort) {\n            _assertContext(sort);\n            return _toExpr(Z3.mk_bound(sort.ctx.ptr, idx, sort.ptr));\n        }\n        function Implies(a, b) {\n            a = from(a);\n            b = from(b);\n            _assertContext(a, b);\n            return new BoolImpl(check(Z3.mk_implies(contextPtr, a.ptr, b.ptr)));\n        }\n        function Eq(a, b) {\n            a = from(a);\n            b = from(b);\n            _assertContext(a, b);\n            return a.eq(b);\n        }\n        function Xor(a, b) {\n            a = from(a);\n            b = from(b);\n            _assertContext(a, b);\n            return new BoolImpl(check(Z3.mk_xor(contextPtr, a.ptr, b.ptr)));\n        }\n        function Not(a) {\n            if (typeof a === 'boolean') {\n                a = from(a);\n            }\n            _assertContext(a);\n            if (isProbe(a)) {\n                return new ProbeImpl(check(Z3.probe_not(contextPtr, a.ptr)));\n            }\n            return new BoolImpl(check(Z3.mk_not(contextPtr, a.ptr)));\n        }\n        function And(...args) {\n            if (args.length == 1 && args[0] instanceof ctx.AstVector) {\n                args = [...args[0].values()];\n                (0, utils_1.assert)((0, utils_1.allSatisfy)(args, isBool) ?? true, 'AstVector containing not bools');\n            }\n            const allProbes = (0, utils_1.allSatisfy)(args, isProbe) ?? false;\n            if (allProbes) {\n                return _probeNary(Z3.probe_and, args);\n            }\n            else {\n                const castArgs = args.map(from);\n                _assertContext(...castArgs);\n                return new BoolImpl(check(Z3.mk_and(contextPtr, castArgs.map(arg => arg.ptr))));\n            }\n        }\n        function Or(...args) {\n            if (args.length == 1 && args[0] instanceof ctx.AstVector) {\n                args = [...args[0].values()];\n                (0, utils_1.assert)((0, utils_1.allSatisfy)(args, isBool) ?? true, 'AstVector containing not bools');\n            }\n            const allProbes = (0, utils_1.allSatisfy)(args, isProbe) ?? false;\n            if (allProbes) {\n                return _probeNary(Z3.probe_or, args);\n            }\n            else {\n                const castArgs = args.map(from);\n                _assertContext(...castArgs);\n                return new BoolImpl(check(Z3.mk_or(contextPtr, castArgs.map(arg => arg.ptr))));\n            }\n        }\n        function ToReal(expr) {\n            expr = from(expr);\n            _assertContext(expr);\n            (0, utils_1.assert)(isInt(expr), 'Int expression expected');\n            return new ArithImpl(check(Z3.mk_int2real(contextPtr, expr.ast)));\n        }\n        function ToInt(expr) {\n            if (!isExpr(expr)) {\n                expr = Real.val(expr);\n            }\n            _assertContext(expr);\n            (0, utils_1.assert)(isReal(expr), 'Real expression expected');\n            return new ArithImpl(check(Z3.mk_real2int(contextPtr, expr.ast)));\n        }\n        function IsInt(expr) {\n            if (!isExpr(expr)) {\n                expr = Real.val(expr);\n            }\n            _assertContext(expr);\n            (0, utils_1.assert)(isReal(expr), 'Real expression expected');\n            return new BoolImpl(check(Z3.mk_is_int(contextPtr, expr.ast)));\n        }\n        function Sqrt(a) {\n            if (!isExpr(a)) {\n                a = Real.val(a);\n            }\n            return a.pow('1/2');\n        }\n        function Cbrt(a) {\n            if (!isExpr(a)) {\n                a = Real.val(a);\n            }\n            return a.pow('1/3');\n        }\n        function BV2Int(a, isSigned) {\n            _assertContext(a);\n            return new ArithImpl(check(Z3.mk_bv2int(contextPtr, a.ast, isSigned)));\n        }\n        function Int2BV(a, bits) {\n            if (isArith(a)) {\n                (0, utils_1.assert)(isInt(a), 'parameter must be an integer');\n            }\n            else {\n                (0, utils_1.assert)(typeof a !== 'number' || Number.isSafeInteger(a), 'parameter must not have decimal places');\n                a = Int.val(a);\n            }\n            return new BitVecImpl(check(Z3.mk_int2bv(contextPtr, bits, a.ast)));\n        }\n        function Concat(...bitvecs) {\n            _assertContext(...bitvecs);\n            return bitvecs.reduce((prev, curr) => new BitVecImpl(check(Z3.mk_concat(contextPtr, prev.ast, curr.ast))));\n        }\n        function Cond(probe, onTrue, onFalse) {\n            _assertContext(probe, onTrue, onFalse);\n            return new TacticImpl(check(Z3.tactic_cond(contextPtr, probe.ptr, onTrue.ptr, onFalse.ptr)));\n        }\n        class AstImpl {\n            constructor(ptr) {\n                this.ptr = ptr;\n                this.ctx = ctx;\n                const myAst = this.ast;\n                Z3.inc_ref(contextPtr, myAst);\n                cleanup.register(this, () => Z3.dec_ref(contextPtr, myAst));\n            }\n            get ast() {\n                return this.ptr;\n            }\n            id() {\n                return Z3.get_ast_id(contextPtr, this.ast);\n            }\n            eqIdentity(other) {\n                _assertContext(other);\n                return check(Z3.is_eq_ast(contextPtr, this.ast, other.ast));\n            }\n            neqIdentity(other) {\n                _assertContext(other);\n                return !this.eqIdentity(other);\n            }\n            sexpr() {\n                return Z3.ast_to_string(contextPtr, this.ast);\n            }\n            hash() {\n                return Z3.get_ast_hash(contextPtr, this.ast);\n            }\n            toString() {\n                return this.sexpr();\n            }\n        }\n        class SolverImpl {\n            constructor(ptr = Z3.mk_solver(contextPtr)) {\n                this.ctx = ctx;\n                let myPtr;\n                if (typeof ptr === 'string') {\n                    myPtr = check(Z3.mk_solver_for_logic(contextPtr, _toSymbol(ptr)));\n                }\n                else {\n                    myPtr = ptr;\n                }\n                this.ptr = myPtr;\n                Z3.solver_inc_ref(contextPtr, myPtr);\n                cleanup.register(this, () => Z3.solver_dec_ref(contextPtr, myPtr));\n            }\n            push() {\n                Z3.solver_push(contextPtr, this.ptr);\n            }\n            pop(num = 1) {\n                Z3.solver_pop(contextPtr, this.ptr, num);\n            }\n            numScopes() {\n                return Z3.solver_get_num_scopes(contextPtr, this.ptr);\n            }\n            reset() {\n                Z3.solver_reset(contextPtr, this.ptr);\n            }\n            add(...exprs) {\n                _flattenArgs(exprs).forEach(expr => {\n                    _assertContext(expr);\n                    check(Z3.solver_assert(contextPtr, this.ptr, expr.ast));\n                });\n            }\n            addAndTrack(expr, constant) {\n                if (typeof constant === 'string') {\n                    constant = Bool.const(constant);\n                }\n                (0, utils_1.assert)(isConst(constant), 'Provided expression that is not a constant to addAndTrack');\n                check(Z3.solver_assert_and_track(contextPtr, this.ptr, expr.ast, constant.ast));\n            }\n            assertions() {\n                return new AstVectorImpl(check(Z3.solver_get_assertions(contextPtr, this.ptr)));\n            }\n            async check(...exprs) {\n                const assumptions = _flattenArgs(exprs).map(expr => {\n                    _assertContext(expr);\n                    return expr.ast;\n                });\n                const result = await asyncMutex.runExclusive(() => check(Z3.solver_check_assumptions(contextPtr, this.ptr, assumptions)));\n                switch (result) {\n                    case low_level_1.Z3_lbool.Z3_L_FALSE:\n                        return 'unsat';\n                    case low_level_1.Z3_lbool.Z3_L_TRUE:\n                        return 'sat';\n                    case low_level_1.Z3_lbool.Z3_L_UNDEF:\n                        return 'unknown';\n                    default:\n                        (0, utils_1.assertExhaustive)(result);\n                }\n            }\n            model() {\n                return new ModelImpl(check(Z3.solver_get_model(contextPtr, this.ptr)));\n            }\n            toString() {\n                return check(Z3.solver_to_string(contextPtr, this.ptr));\n            }\n        }\n        class ModelImpl {\n            constructor(ptr = Z3.mk_model(contextPtr)) {\n                this.ptr = ptr;\n                this.ctx = ctx;\n                Z3.model_inc_ref(contextPtr, ptr);\n                cleanup.register(this, () => Z3.model_dec_ref(contextPtr, ptr));\n            }\n            length() {\n                return Z3.model_get_num_consts(contextPtr, this.ptr) + Z3.model_get_num_funcs(contextPtr, this.ptr);\n            }\n            [Symbol.iterator]() {\n                return this.values();\n            }\n            *entries() {\n                const length = this.length();\n                for (let i = 0; i < length; i++) {\n                    yield [i, this.get(i)];\n                }\n            }\n            *keys() {\n                for (const [key] of this.entries()) {\n                    yield key;\n                }\n            }\n            *values() {\n                for (const [, value] of this.entries()) {\n                    yield value;\n                }\n            }\n            decls() {\n                return [...this.values()];\n            }\n            sexpr() {\n                return check(Z3.model_to_string(contextPtr, this.ptr));\n            }\n            eval(expr, modelCompletion = false) {\n                _assertContext(expr);\n                const r = check(Z3.model_eval(contextPtr, this.ptr, expr.ast, modelCompletion));\n                if (r === null) {\n                    throw new types_1.Z3Error('Failed to evaluatio expression in the model');\n                }\n                return _toExpr(r);\n            }\n            get(i, to) {\n                (0, utils_1.assert)(to === undefined || typeof i === 'number');\n                if (typeof i === 'number') {\n                    const length = this.length();\n                    if (i >= length) {\n                        throw new RangeError(`expected index ${i} to be less than length ${length}`);\n                    }\n                    if (to === undefined) {\n                        const numConsts = check(Z3.model_get_num_consts(contextPtr, this.ptr));\n                        if (i < numConsts) {\n                            return new FuncDeclImpl(check(Z3.model_get_const_decl(contextPtr, this.ptr, i)));\n                        }\n                        else {\n                            return new FuncDeclImpl(check(Z3.model_get_func_decl(contextPtr, this.ptr, i - numConsts)));\n                        }\n                    }\n                    if (to < 0) {\n                        to += length;\n                    }\n                    if (to >= length) {\n                        throw new RangeError(`expected index ${to} to be less than length ${length}`);\n                    }\n                    const result = [];\n                    for (let j = i; j < to; j++) {\n                        result.push(this.get(j));\n                    }\n                    return result;\n                }\n                else if (isFuncDecl(i) || (isExpr(i) && isConst(i))) {\n                    const result = this.getInterp(i);\n                    (0, utils_1.assert)(result !== null);\n                    return result;\n                }\n                else if (isSort(i)) {\n                    return this.getUniverse(i);\n                }\n                (0, utils_1.assert)(false, 'Number, declaration or constant expected');\n            }\n            getInterp(expr) {\n                (0, utils_1.assert)(isFuncDecl(expr) || isConst(expr), 'Declaration expected');\n                if (isConst(expr)) {\n                    (0, utils_1.assert)(isExpr(expr));\n                    expr = expr.decl();\n                }\n                (0, utils_1.assert)(isFuncDecl(expr));\n                if (expr.arity() === 0) {\n                    const result = check(Z3.model_get_const_interp(contextPtr, this.ptr, expr.ptr));\n                    if (result === null) {\n                        return null;\n                    }\n                    return _toExpr(result);\n                }\n                else {\n                    const interp = check(Z3.model_get_func_interp(contextPtr, this.ptr, expr.ptr));\n                    if (interp === null) {\n                        return null;\n                    }\n                    return new FuncInterpImpl(interp);\n                }\n            }\n            getUniverse(sort) {\n                _assertContext(sort);\n                return new AstVectorImpl(check(Z3.model_get_sort_universe(contextPtr, this.ptr, sort.ptr)));\n            }\n        }\n        class FuncInterpImpl {\n            constructor(ptr) {\n                this.ptr = ptr;\n                this.ctx = ctx;\n                Z3.func_interp_inc_ref(contextPtr, ptr);\n                cleanup.register(this, () => Z3.func_interp_dec_ref(contextPtr, ptr));\n            }\n        }\n        class SortImpl extends AstImpl {\n            get ast() {\n                return Z3.sort_to_ast(contextPtr, this.ptr);\n            }\n            kind() {\n                return Z3.get_sort_kind(contextPtr, this.ptr);\n            }\n            subsort(other) {\n                _assertContext(other);\n                return false;\n            }\n            cast(expr) {\n                _assertContext(expr);\n                (0, utils_1.assert)(expr.sort.eqIdentity(expr.sort), 'Sort mismatch');\n                return expr;\n            }\n            name() {\n                return _fromSymbol(Z3.get_sort_name(contextPtr, this.ptr));\n            }\n            eqIdentity(other) {\n                _assertContext(other);\n                return check(Z3.is_eq_sort(contextPtr, this.ptr, other.ptr));\n            }\n            neqIdentity(other) {\n                return !this.eqIdentity(other);\n            }\n        }\n        class FuncDeclImpl extends AstImpl {\n            get ast() {\n                return Z3.func_decl_to_ast(contextPtr, this.ptr);\n            }\n            name() {\n                return _fromSymbol(Z3.get_decl_name(contextPtr, this.ptr));\n            }\n            arity() {\n                return Z3.get_arity(contextPtr, this.ptr);\n            }\n            domain(i) {\n                (0, utils_1.assert)(i < this.arity(), 'Index out of bounds');\n                return _toSort(Z3.get_domain(contextPtr, this.ptr, i));\n            }\n            range() {\n                return _toSort(Z3.get_range(contextPtr, this.ptr));\n            }\n            kind() {\n                return Z3.get_decl_kind(contextPtr, this.ptr);\n            }\n            params() {\n                const n = Z3.get_decl_num_parameters(contextPtr, this.ptr);\n                const result = [];\n                for (let i = 0; i < n; i++) {\n                    const kind = check(Z3.get_decl_parameter_kind(contextPtr, this.ptr, i));\n                    switch (kind) {\n                        case low_level_1.Z3_parameter_kind.Z3_PARAMETER_INT:\n                            result.push(check(Z3.get_decl_int_parameter(contextPtr, this.ptr, i)));\n                            break;\n                        case low_level_1.Z3_parameter_kind.Z3_PARAMETER_DOUBLE:\n                            result.push(check(Z3.get_decl_double_parameter(contextPtr, this.ptr, i)));\n                            break;\n                        case low_level_1.Z3_parameter_kind.Z3_PARAMETER_RATIONAL:\n                            result.push(check(Z3.get_decl_rational_parameter(contextPtr, this.ptr, i)));\n                            break;\n                        case low_level_1.Z3_parameter_kind.Z3_PARAMETER_SYMBOL:\n                            result.push(check(Z3.get_decl_symbol_parameter(contextPtr, this.ptr, i)));\n                            break;\n                        case low_level_1.Z3_parameter_kind.Z3_PARAMETER_SORT:\n                            result.push(new SortImpl(check(Z3.get_decl_sort_parameter(contextPtr, this.ptr, i))));\n                            break;\n                        case low_level_1.Z3_parameter_kind.Z3_PARAMETER_AST:\n                            result.push(new ExprImpl(check(Z3.get_decl_ast_parameter(contextPtr, this.ptr, i))));\n                            break;\n                        case low_level_1.Z3_parameter_kind.Z3_PARAMETER_FUNC_DECL:\n                            result.push(new FuncDeclImpl(check(Z3.get_decl_func_decl_parameter(contextPtr, this.ptr, i))));\n                            break;\n                        default:\n                            (0, utils_1.assertExhaustive)(kind);\n                    }\n                }\n                return result;\n            }\n            call(...args) {\n                (0, utils_1.assert)(args.length === this.arity(), `Incorrect number of arguments to ${this}`);\n                return _toExpr(check(Z3.mk_app(contextPtr, this.ptr, args.map((arg, i) => {\n                    return this.domain(i).cast(arg).ast;\n                }))));\n            }\n        }\n        class ExprImpl extends AstImpl {\n            get sort() {\n                return _toSort(Z3.get_sort(contextPtr, this.ast));\n            }\n            eq(other) {\n                return new BoolImpl(check(Z3.mk_eq(contextPtr, this.ast, from(other).ast)));\n            }\n            neq(other) {\n                return new BoolImpl(check(Z3.mk_distinct(contextPtr, [this, other].map(expr => from(expr).ast))));\n            }\n            params() {\n                return this.decl().params();\n            }\n            decl() {\n                (0, utils_1.assert)(isApp(this), 'Z3 application expected');\n                return new FuncDeclImpl(check(Z3.get_app_decl(contextPtr, check(Z3.to_app(contextPtr, this.ast)))));\n            }\n            numArgs() {\n                (0, utils_1.assert)(isApp(this), 'Z3 applicaiton expected');\n                return check(Z3.get_app_num_args(contextPtr, check(Z3.to_app(contextPtr, this.ast))));\n            }\n            arg(i) {\n                (0, utils_1.assert)(isApp(this), 'Z3 applicaiton expected');\n                (0, utils_1.assert)(i < this.numArgs(), `Invalid argument index - expected ${i} to be less than ${this.numArgs()}`);\n                return _toExpr(check(Z3.get_app_arg(contextPtr, check(Z3.to_app(contextPtr, this.ast)), i)));\n            }\n            children() {\n                const num_args = this.numArgs();\n                if (isApp(this)) {\n                    const result = [];\n                    for (let i = 0; i < num_args; i++) {\n                        result.push(this.arg(i));\n                    }\n                    return result;\n                }\n                return [];\n            }\n        }\n        class BoolSortImpl extends SortImpl {\n            cast(other) {\n                if (typeof other === 'boolean') {\n                    other = Bool.val(other);\n                }\n                (0, utils_1.assert)(isExpr(other), 'true, false or Z3 Boolean expression expected.');\n                (0, utils_1.assert)(this.eqIdentity(other.sort), 'Value cannot be converted into a Z3 Boolean value');\n                return other;\n            }\n            subsort(other) {\n                _assertContext(other.ctx);\n                return other instanceof ArithSortImpl;\n            }\n        }\n        class BoolImpl extends ExprImpl {\n            not() {\n                return Not(this);\n            }\n            and(other) {\n                return And(this, other);\n            }\n            or(other) {\n                return Or(this, other);\n            }\n            xor(other) {\n                return Xor(this, other);\n            }\n        }\n        class ProbeImpl {\n            constructor(ptr) {\n                this.ptr = ptr;\n                this.ctx = ctx;\n            }\n        }\n        class TacticImpl {\n            constructor(tactic) {\n                this.ctx = ctx;\n                let myPtr;\n                if (typeof tactic === 'string') {\n                    myPtr = check(Z3.mk_tactic(contextPtr, tactic));\n                }\n                else {\n                    myPtr = tactic;\n                }\n                this.ptr = myPtr;\n                Z3.tactic_inc_ref(contextPtr, myPtr);\n                cleanup.register(this, () => Z3.tactic_dec_ref(contextPtr, myPtr));\n            }\n        }\n        class ArithSortImpl extends SortImpl {\n            cast(other) {\n                const sortTypeStr = isIntSort(this) ? 'IntSort' : 'RealSort';\n                if (isExpr(other)) {\n                    const otherS = other.sort;\n                    if (isArith(other)) {\n                        if (this.eqIdentity(otherS)) {\n                            return other;\n                        }\n                        else if (isIntSort(otherS) && isRealSort(this)) {\n                            return ToReal(other);\n                        }\n                        (0, utils_1.assert)(false, \"Can't cast Real to IntSort without loss\");\n                    }\n                    else if (isBool(other)) {\n                        if (isIntSort(this)) {\n                            return If(other, 1, 0);\n                        }\n                        else {\n                            return ToReal(If(other, 1, 0));\n                        }\n                    }\n                    (0, utils_1.assert)(false, `Can't cast expression to ${sortTypeStr}`);\n                }\n                else {\n                    if (typeof other !== 'boolean') {\n                        if (isIntSort(this)) {\n                            (0, utils_1.assert)(!isCoercibleRational(other), \"Can't cast fraction to IntSort\");\n                            return Int.val(other);\n                        }\n                        return Real.val(other);\n                    }\n                    (0, utils_1.assert)(false, `Can't cast primitive to ${sortTypeStr}`);\n                }\n            }\n        }\n        class ArithImpl extends ExprImpl {\n            add(other) {\n                return new ArithImpl(check(Z3.mk_add(contextPtr, [this.ast, this.sort.cast(other).ast])));\n            }\n            mul(other) {\n                return new ArithImpl(check(Z3.mk_mul(contextPtr, [this.ast, this.sort.cast(other).ast])));\n            }\n            sub(other) {\n                return new ArithImpl(check(Z3.mk_sub(contextPtr, [this.ast, this.sort.cast(other).ast])));\n            }\n            pow(exponent) {\n                return new ArithImpl(check(Z3.mk_power(contextPtr, this.ast, this.sort.cast(exponent).ast)));\n            }\n            div(other) {\n                return new ArithImpl(check(Z3.mk_div(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            mod(other) {\n                return new ArithImpl(check(Z3.mk_mod(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            neg() {\n                return new ArithImpl(check(Z3.mk_unary_minus(contextPtr, this.ast)));\n            }\n            le(other) {\n                return new BoolImpl(check(Z3.mk_le(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            lt(other) {\n                return new BoolImpl(check(Z3.mk_lt(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            gt(other) {\n                return new BoolImpl(check(Z3.mk_gt(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            ge(other) {\n                return new BoolImpl(check(Z3.mk_ge(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n        }\n        class IntNumImpl extends ArithImpl {\n            value() {\n                return BigInt(this.asString());\n            }\n            asString() {\n                return Z3.get_numeral_string(contextPtr, this.ast);\n            }\n            asBinary() {\n                return Z3.get_numeral_binary_string(contextPtr, this.ast);\n            }\n        }\n        class RatNumImpl extends ArithImpl {\n            value() {\n                return { numerator: this.numerator().value(), denominator: this.denominator().value() };\n            }\n            numerator() {\n                return new IntNumImpl(Z3.get_numerator(contextPtr, this.ast));\n            }\n            denominator() {\n                return new IntNumImpl(Z3.get_denominator(contextPtr, this.ast));\n            }\n            asNumber() {\n                const { numerator, denominator } = this.value();\n                const div = numerator / denominator;\n                return Number(div) + Number(numerator - div * denominator) / Number(denominator);\n            }\n            asDecimal(prec = Number.parseInt(getParam('precision') ?? FALLBACK_PRECISION.toString())) {\n                return Z3.get_numeral_decimal_string(contextPtr, this.ast, prec);\n            }\n            asString() {\n                return Z3.get_numeral_string(contextPtr, this.ast);\n            }\n        }\n        class BitVecSortImpl extends SortImpl {\n            size() {\n                return Z3.get_bv_sort_size(contextPtr, this.ptr);\n            }\n            subsort(other) {\n                return isBitVecSort(other) && this.size() < other.size();\n            }\n            cast(other) {\n                if (isExpr(other)) {\n                    _assertContext(other);\n                    return other;\n                }\n                (0, utils_1.assert)(!isCoercibleRational(other), \"Can't convert rational to BitVec\");\n                return BitVec.val(other, this.size());\n            }\n        }\n        class BitVecImpl extends ExprImpl {\n            size() {\n                return this.sort.size();\n            }\n            add(other) {\n                return new BitVecImpl(check(Z3.mk_bvadd(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            mul(other) {\n                return new BitVecImpl(check(Z3.mk_bvmul(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            sub(other) {\n                return new BitVecImpl(check(Z3.mk_bvsub(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            sdiv(other) {\n                return new BitVecImpl(check(Z3.mk_bvsdiv(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            udiv(other) {\n                return new BitVecImpl(check(Z3.mk_bvudiv(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            smod(other) {\n                return new BitVecImpl(check(Z3.mk_bvsmod(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            urem(other) {\n                return new BitVecImpl(check(Z3.mk_bvurem(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            srem(other) {\n                return new BitVecImpl(check(Z3.mk_bvsrem(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            neg() {\n                return new BitVecImpl(check(Z3.mk_bvneg(contextPtr, this.ast)));\n            }\n            or(other) {\n                return new BitVecImpl(check(Z3.mk_bvor(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            and(other) {\n                return new BitVecImpl(check(Z3.mk_bvand(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            nand(other) {\n                return new BitVecImpl(check(Z3.mk_bvnand(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            xor(other) {\n                return new BitVecImpl(check(Z3.mk_bvxor(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            xnor(other) {\n                return new BitVecImpl(check(Z3.mk_bvxnor(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            shr(count) {\n                return new BitVecImpl(check(Z3.mk_bvashr(contextPtr, this.ast, this.sort.cast(count).ast)));\n            }\n            lshr(count) {\n                return new BitVecImpl(check(Z3.mk_bvlshr(contextPtr, this.ast, this.sort.cast(count).ast)));\n            }\n            shl(count) {\n                return new BitVecImpl(check(Z3.mk_bvshl(contextPtr, this.ast, this.sort.cast(count).ast)));\n            }\n            rotateRight(count) {\n                return new BitVecImpl(check(Z3.mk_ext_rotate_right(contextPtr, this.ast, this.sort.cast(count).ast)));\n            }\n            rotateLeft(count) {\n                return new BitVecImpl(check(Z3.mk_ext_rotate_left(contextPtr, this.ast, this.sort.cast(count).ast)));\n            }\n            not() {\n                return new BitVecImpl(check(Z3.mk_bvnot(contextPtr, this.ast)));\n            }\n            extract(high, low) {\n                return new BitVecImpl(check(Z3.mk_extract(contextPtr, high, low, this.ast)));\n            }\n            signExt(count) {\n                return new BitVecImpl(check(Z3.mk_sign_ext(contextPtr, count, this.ast)));\n            }\n            zeroExt(count) {\n                return new BitVecImpl(check(Z3.mk_zero_ext(contextPtr, count, this.ast)));\n            }\n            repeat(count) {\n                return new BitVecImpl(check(Z3.mk_repeat(contextPtr, count, this.ast)));\n            }\n            sle(other) {\n                return new BoolImpl(check(Z3.mk_bvsle(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            ule(other) {\n                return new BoolImpl(check(Z3.mk_bvule(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            slt(other) {\n                return new BoolImpl(check(Z3.mk_bvslt(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            ult(other) {\n                return new BoolImpl(check(Z3.mk_bvult(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            sge(other) {\n                return new BoolImpl(check(Z3.mk_bvsge(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            uge(other) {\n                return new BoolImpl(check(Z3.mk_bvuge(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            sgt(other) {\n                return new BoolImpl(check(Z3.mk_bvsgt(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            ugt(other) {\n                return new BoolImpl(check(Z3.mk_bvugt(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            redAnd() {\n                return new BitVecImpl(check(Z3.mk_bvredand(contextPtr, this.ast)));\n            }\n            redOr() {\n                return new BitVecImpl(check(Z3.mk_bvredor(contextPtr, this.ast)));\n            }\n            addNoOverflow(other, isSigned) {\n                return new BoolImpl(check(Z3.mk_bvadd_no_overflow(contextPtr, this.ast, this.sort.cast(other).ast, isSigned)));\n            }\n            addNoUnderflow(other) {\n                return new BoolImpl(check(Z3.mk_bvadd_no_underflow(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            subNoOverflow(other) {\n                return new BoolImpl(check(Z3.mk_bvsub_no_overflow(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            subNoUndeflow(other, isSigned) {\n                return new BoolImpl(check(Z3.mk_bvsub_no_underflow(contextPtr, this.ast, this.sort.cast(other).ast, isSigned)));\n            }\n            sdivNoOverflow(other) {\n                return new BoolImpl(check(Z3.mk_bvsdiv_no_overflow(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            mulNoOverflow(other, isSigned) {\n                return new BoolImpl(check(Z3.mk_bvmul_no_overflow(contextPtr, this.ast, this.sort.cast(other).ast, isSigned)));\n            }\n            mulNoUndeflow(other) {\n                return new BoolImpl(check(Z3.mk_bvmul_no_underflow(contextPtr, this.ast, this.sort.cast(other).ast)));\n            }\n            negNoOverflow() {\n                return new BoolImpl(check(Z3.mk_bvneg_no_overflow(contextPtr, this.ast)));\n            }\n        }\n        class BitVecNumImpl extends BitVecImpl {\n            value() {\n                return BigInt(this.asString());\n            }\n            asSignedValue() {\n                let val = this.value();\n                const size = BigInt(this.size());\n                if (val >= 2n ** (size - 1n)) {\n                    val = val - 2n ** size;\n                }\n                if (val < (-2n) ** (size - 1n)) {\n                    val = val + 2n ** size;\n                }\n                return val;\n            }\n            asString() {\n                return Z3.get_numeral_string(contextPtr, this.ast);\n            }\n            asBinaryString() {\n                return Z3.get_numeral_binary_string(contextPtr, this.ast);\n            }\n        }\n        class AstVectorImpl {\n            constructor(ptr = Z3.mk_ast_vector(contextPtr)) {\n                this.ptr = ptr;\n                this.ctx = ctx;\n                Z3.ast_vector_inc_ref(contextPtr, ptr);\n                cleanup.register(this, () => Z3.ast_vector_dec_ref(contextPtr, ptr));\n            }\n            length() {\n                return Z3.ast_vector_size(contextPtr, this.ptr);\n            }\n            [Symbol.iterator]() {\n                return this.values();\n            }\n            *entries() {\n                const length = this.length();\n                for (let i = 0; i < length; i++) {\n                    yield [i, this.get(i)];\n                }\n            }\n            *keys() {\n                for (let [key] of this.entries()) {\n                    yield key;\n                }\n            }\n            *values() {\n                for (let [, value] of this.entries()) {\n                    yield value;\n                }\n            }\n            get(from, to) {\n                const length = this.length();\n                if (from < 0) {\n                    from += length;\n                }\n                if (from >= length) {\n                    throw new RangeError(`expected from index ${from} to be less than length ${length}`);\n                }\n                if (to === undefined) {\n                    return _toAst(check(Z3.ast_vector_get(contextPtr, this.ptr, from)));\n                }\n                if (to < 0) {\n                    to += length;\n                }\n                if (to >= length) {\n                    throw new RangeError(`expected to index ${to} to be less than length ${length}`);\n                }\n                const result = [];\n                for (let i = from; i < to; i++) {\n                    result.push(_toAst(check(Z3.ast_vector_get(contextPtr, this.ptr, i))));\n                }\n                return result;\n            }\n            set(i, v) {\n                _assertContext(v);\n                if (i >= this.length()) {\n                    throw new RangeError(`expected index ${i} to be less than length ${this.length()}`);\n                }\n                check(Z3.ast_vector_set(contextPtr, this.ptr, i, v.ast));\n            }\n            push(v) {\n                _assertContext(v);\n                check(Z3.ast_vector_push(contextPtr, this.ptr, v.ast));\n            }\n            resize(size) {\n                check(Z3.ast_vector_resize(contextPtr, this.ptr, size));\n            }\n            has(v) {\n                _assertContext(v);\n                for (const item of this.values()) {\n                    if (item.eqIdentity(v)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            sexpr() {\n                return check(Z3.ast_vector_to_string(contextPtr, this.ptr));\n            }\n        }\n        class AstMapImpl {\n            constructor(ptr = Z3.mk_ast_map(contextPtr)) {\n                this.ptr = ptr;\n                this.ctx = ctx;\n                Z3.ast_map_inc_ref(contextPtr, ptr);\n                cleanup.register(this, () => Z3.ast_map_dec_ref(contextPtr, ptr));\n            }\n            [Symbol.iterator]() {\n                return this.entries();\n            }\n            get size() {\n                return Z3.ast_map_size(contextPtr, this.ptr);\n            }\n            *entries() {\n                for (const key of this.keys()) {\n                    yield [key, this.get(key)];\n                }\n            }\n            keys() {\n                return new AstVectorImpl(Z3.ast_map_keys(contextPtr, this.ptr));\n            }\n            *values() {\n                for (const [_, value] of this.entries()) {\n                    yield value;\n                }\n            }\n            get(key) {\n                return _toAst(check(Z3.ast_map_find(contextPtr, this.ptr, key.ast)));\n            }\n            set(key, value) {\n                check(Z3.ast_map_insert(contextPtr, this.ptr, key.ast, value.ast));\n            }\n            delete(key) {\n                check(Z3.ast_map_erase(contextPtr, this.ptr, key.ast));\n            }\n            clear() {\n                check(Z3.ast_map_reset(contextPtr, this.ptr));\n            }\n            has(key) {\n                return check(Z3.ast_map_contains(contextPtr, this.ptr, key.ast));\n            }\n            sexpr() {\n                return check(Z3.ast_map_to_string(contextPtr, this.ptr));\n            }\n        }\n        const ctx = {\n            ptr: contextPtr,\n            name,\n            /////////////\n            // Classes //\n            /////////////\n            Solver: SolverImpl,\n            Model: ModelImpl,\n            Tactic: TacticImpl,\n            AstVector: AstVectorImpl,\n            AstMap: AstMapImpl,\n            ///////////////\n            // Functions //\n            ///////////////\n            interrupt,\n            isModel,\n            isAst,\n            isSort,\n            isFuncDecl,\n            isApp,\n            isConst,\n            isExpr,\n            isVar,\n            isAppOf,\n            isBool,\n            isTrue,\n            isFalse,\n            isAnd,\n            isOr,\n            isImplies,\n            isNot,\n            isEq,\n            isDistinct,\n            isArith,\n            isArithSort,\n            isInt,\n            isIntVal,\n            isIntSort,\n            isReal,\n            isRealVal,\n            isRealSort,\n            isBitVecSort,\n            isBitVec,\n            isBitVecVal,\n            isProbe,\n            isTactic,\n            isAstVector,\n            eqIdentity,\n            getVarIndex,\n            from,\n            solve,\n            /////////////\n            // Objects //\n            /////////////\n            Sort,\n            Function,\n            RecFunc,\n            Bool,\n            Int,\n            Real,\n            BitVec,\n            ////////////////\n            // Operations //\n            ////////////////\n            If,\n            Distinct,\n            Const,\n            Consts,\n            FreshConst,\n            Var,\n            Implies,\n            Eq,\n            Xor,\n            Not,\n            And,\n            Or,\n            ToReal,\n            ToInt,\n            IsInt,\n            Sqrt,\n            Cbrt,\n            BV2Int,\n            Int2BV,\n            Concat,\n            Cond,\n        };\n        cleanup.register(ctx, () => Z3.del_context(contextPtr));\n        return ctx;\n    }\n    return {\n        enableTrace,\n        disableTrace,\n        getVersion,\n        getVersionString,\n        getFullVersion,\n        openLog,\n        appendLog,\n        getParam,\n        setParam,\n        resetParams,\n        Context: createContext,\n    };\n}\nexports.createApi = createApi;\n\n\n//# sourceURL=webpack:///./node_modules/z3-solver/build/high-level/high-level.js?");

/***/ }),

/***/ "./node_modules/z3-solver/build/high-level/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/z3-solver/build/high-level/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./high-level */ \"./node_modules/z3-solver/build/high-level/high-level.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types */ \"./node_modules/z3-solver/build/high-level/types.js\"), exports);\n\n\n//# sourceURL=webpack:///./node_modules/z3-solver/build/high-level/index.js?");

/***/ }),

/***/ "./node_modules/z3-solver/build/high-level/types.js":
/*!**********************************************************!*\
  !*** ./node_modules/z3-solver/build/high-level/types.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Z3AssertionError = exports.Z3Error = void 0;\nclass Z3Error extends Error {\n}\nexports.Z3Error = Z3Error;\nclass Z3AssertionError extends Z3Error {\n}\nexports.Z3AssertionError = Z3AssertionError;\n\n\n//# sourceURL=webpack:///./node_modules/z3-solver/build/high-level/types.js?");

/***/ }),

/***/ "./node_modules/z3-solver/build/high-level/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/z3-solver/build/high-level/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.allSatisfy = exports.assert = exports.assertExhaustive = void 0;\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/z3-solver/build/high-level/types.js\");\nfunction getAllProperties(obj) {\n    const properties = new Set();\n    do {\n        for (const key of Reflect.ownKeys(obj)) {\n            properties.add([obj, key]);\n        }\n    } while ((obj = Reflect.getPrototypeOf(obj)) && obj !== Object.prototype);\n    return properties;\n}\n/**\n * Use to ensure that switches are checked to be exhaustive at compile time\n *\n * @example Basic usage\n * ```typescript\n * enum Something {\n *  left,\n *  right,\n * };\n * const something = getSomething();\n * switch (something) {\n *  case Something.left:\n *    ...\n *  case Something.right:\n *    ...\n *  default:\n *    assertExhaustive(something);\n * }\n * ```\n *\n * @param x - The param on which the switch operates\n */\nfunction assertExhaustive(x) {\n    throw new Error('Unexpected code execution detected, should be caught at compile time');\n}\nexports.assertExhaustive = assertExhaustive;\nfunction assert(condition, reason) {\n    if (!condition) {\n        throw new types_1.Z3AssertionError(reason ?? 'Assertion failed');\n    }\n}\nexports.assert = assert;\n/**\n * Check the all elements of a `collection` satisfy the `premise`.\n * If any of the items fail the `premise`, returns false;\n * @returns null if the `collection` is empty, boolean otherwise\n */\nfunction allSatisfy(collection, premise) {\n    let hasItems = false;\n    for (const arg of collection) {\n        hasItems = true;\n        if (!premise(arg)) {\n            return false;\n        }\n    }\n    return hasItems === true ? true : null;\n}\nexports.allSatisfy = allSatisfy;\n\n\n//# sourceURL=webpack:///./node_modules/z3-solver/build/high-level/utils.js?");

/***/ }),

/***/ "./node_modules/z3-solver/build/low-level/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/z3-solver/build/low-level/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./types.__GENERATED__ */ \"./node_modules/z3-solver/build/low-level/types.__GENERATED__.js\"), exports);\n__exportStar(__webpack_require__(/*! ./wrapper.__GENERATED__ */ \"./node_modules/z3-solver/build/low-level/wrapper.__GENERATED__.js\"), exports);\n\n\n//# sourceURL=webpack:///./node_modules/z3-solver/build/low-level/index.js?");

/***/ }),

/***/ "./node_modules/z3-solver/build/low-level/types.__GENERATED__.js":
/*!***********************************************************************!*\
  !*** ./node_modules/z3-solver/build/low-level/types.__GENERATED__.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// THIS FILE IS AUTOMATICALLY GENERATED BY make-ts-wrapper.ts\n// DO NOT EDIT IT BY HAND\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Z3_goal_prec = exports.Z3_error_code = exports.Z3_ast_print_mode = exports.Z3_param_kind = exports.Z3_decl_kind = exports.Z3_ast_kind = exports.Z3_sort_kind = exports.Z3_parameter_kind = exports.Z3_symbol_kind = exports.Z3_lbool = void 0;\nvar Z3_lbool;\n(function (Z3_lbool) {\n    Z3_lbool[Z3_lbool[\"Z3_L_FALSE\"] = -1] = \"Z3_L_FALSE\";\n    Z3_lbool[Z3_lbool[\"Z3_L_UNDEF\"] = 0] = \"Z3_L_UNDEF\";\n    Z3_lbool[Z3_lbool[\"Z3_L_TRUE\"] = 1] = \"Z3_L_TRUE\";\n})(Z3_lbool = exports.Z3_lbool || (exports.Z3_lbool = {}));\nvar Z3_symbol_kind;\n(function (Z3_symbol_kind) {\n    Z3_symbol_kind[Z3_symbol_kind[\"Z3_INT_SYMBOL\"] = 0] = \"Z3_INT_SYMBOL\";\n    Z3_symbol_kind[Z3_symbol_kind[\"Z3_STRING_SYMBOL\"] = 1] = \"Z3_STRING_SYMBOL\";\n})(Z3_symbol_kind = exports.Z3_symbol_kind || (exports.Z3_symbol_kind = {}));\nvar Z3_parameter_kind;\n(function (Z3_parameter_kind) {\n    Z3_parameter_kind[Z3_parameter_kind[\"Z3_PARAMETER_INT\"] = 0] = \"Z3_PARAMETER_INT\";\n    Z3_parameter_kind[Z3_parameter_kind[\"Z3_PARAMETER_DOUBLE\"] = 1] = \"Z3_PARAMETER_DOUBLE\";\n    Z3_parameter_kind[Z3_parameter_kind[\"Z3_PARAMETER_RATIONAL\"] = 2] = \"Z3_PARAMETER_RATIONAL\";\n    Z3_parameter_kind[Z3_parameter_kind[\"Z3_PARAMETER_SYMBOL\"] = 3] = \"Z3_PARAMETER_SYMBOL\";\n    Z3_parameter_kind[Z3_parameter_kind[\"Z3_PARAMETER_SORT\"] = 4] = \"Z3_PARAMETER_SORT\";\n    Z3_parameter_kind[Z3_parameter_kind[\"Z3_PARAMETER_AST\"] = 5] = \"Z3_PARAMETER_AST\";\n    Z3_parameter_kind[Z3_parameter_kind[\"Z3_PARAMETER_FUNC_DECL\"] = 6] = \"Z3_PARAMETER_FUNC_DECL\";\n})(Z3_parameter_kind = exports.Z3_parameter_kind || (exports.Z3_parameter_kind = {}));\nvar Z3_sort_kind;\n(function (Z3_sort_kind) {\n    Z3_sort_kind[Z3_sort_kind[\"Z3_UNINTERPRETED_SORT\"] = 0] = \"Z3_UNINTERPRETED_SORT\";\n    Z3_sort_kind[Z3_sort_kind[\"Z3_BOOL_SORT\"] = 1] = \"Z3_BOOL_SORT\";\n    Z3_sort_kind[Z3_sort_kind[\"Z3_INT_SORT\"] = 2] = \"Z3_INT_SORT\";\n    Z3_sort_kind[Z3_sort_kind[\"Z3_REAL_SORT\"] = 3] = \"Z3_REAL_SORT\";\n    Z3_sort_kind[Z3_sort_kind[\"Z3_BV_SORT\"] = 4] = \"Z3_BV_SORT\";\n    Z3_sort_kind[Z3_sort_kind[\"Z3_ARRAY_SORT\"] = 5] = \"Z3_ARRAY_SORT\";\n    Z3_sort_kind[Z3_sort_kind[\"Z3_DATATYPE_SORT\"] = 6] = \"Z3_DATATYPE_SORT\";\n    Z3_sort_kind[Z3_sort_kind[\"Z3_RELATION_SORT\"] = 7] = \"Z3_RELATION_SORT\";\n    Z3_sort_kind[Z3_sort_kind[\"Z3_FINITE_DOMAIN_SORT\"] = 8] = \"Z3_FINITE_DOMAIN_SORT\";\n    Z3_sort_kind[Z3_sort_kind[\"Z3_FLOATING_POINT_SORT\"] = 9] = \"Z3_FLOATING_POINT_SORT\";\n    Z3_sort_kind[Z3_sort_kind[\"Z3_ROUNDING_MODE_SORT\"] = 10] = \"Z3_ROUNDING_MODE_SORT\";\n    Z3_sort_kind[Z3_sort_kind[\"Z3_SEQ_SORT\"] = 11] = \"Z3_SEQ_SORT\";\n    Z3_sort_kind[Z3_sort_kind[\"Z3_RE_SORT\"] = 12] = \"Z3_RE_SORT\";\n    Z3_sort_kind[Z3_sort_kind[\"Z3_CHAR_SORT\"] = 13] = \"Z3_CHAR_SORT\";\n    Z3_sort_kind[Z3_sort_kind[\"Z3_UNKNOWN_SORT\"] = 1000] = \"Z3_UNKNOWN_SORT\";\n})(Z3_sort_kind = exports.Z3_sort_kind || (exports.Z3_sort_kind = {}));\nvar Z3_ast_kind;\n(function (Z3_ast_kind) {\n    Z3_ast_kind[Z3_ast_kind[\"Z3_NUMERAL_AST\"] = 0] = \"Z3_NUMERAL_AST\";\n    Z3_ast_kind[Z3_ast_kind[\"Z3_APP_AST\"] = 1] = \"Z3_APP_AST\";\n    Z3_ast_kind[Z3_ast_kind[\"Z3_VAR_AST\"] = 2] = \"Z3_VAR_AST\";\n    Z3_ast_kind[Z3_ast_kind[\"Z3_QUANTIFIER_AST\"] = 3] = \"Z3_QUANTIFIER_AST\";\n    Z3_ast_kind[Z3_ast_kind[\"Z3_SORT_AST\"] = 4] = \"Z3_SORT_AST\";\n    Z3_ast_kind[Z3_ast_kind[\"Z3_FUNC_DECL_AST\"] = 5] = \"Z3_FUNC_DECL_AST\";\n    Z3_ast_kind[Z3_ast_kind[\"Z3_UNKNOWN_AST\"] = 1000] = \"Z3_UNKNOWN_AST\";\n})(Z3_ast_kind = exports.Z3_ast_kind || (exports.Z3_ast_kind = {}));\nvar Z3_decl_kind;\n(function (Z3_decl_kind) {\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_TRUE\"] = 256] = \"Z3_OP_TRUE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FALSE\"] = 257] = \"Z3_OP_FALSE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_EQ\"] = 258] = \"Z3_OP_EQ\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_DISTINCT\"] = 259] = \"Z3_OP_DISTINCT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_ITE\"] = 260] = \"Z3_OP_ITE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_AND\"] = 261] = \"Z3_OP_AND\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_OR\"] = 262] = \"Z3_OP_OR\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_IFF\"] = 263] = \"Z3_OP_IFF\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_XOR\"] = 264] = \"Z3_OP_XOR\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_NOT\"] = 265] = \"Z3_OP_NOT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_IMPLIES\"] = 266] = \"Z3_OP_IMPLIES\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_OEQ\"] = 267] = \"Z3_OP_OEQ\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_ANUM\"] = 512] = \"Z3_OP_ANUM\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_AGNUM\"] = 513] = \"Z3_OP_AGNUM\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_LE\"] = 514] = \"Z3_OP_LE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_GE\"] = 515] = \"Z3_OP_GE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_LT\"] = 516] = \"Z3_OP_LT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_GT\"] = 517] = \"Z3_OP_GT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_ADD\"] = 518] = \"Z3_OP_ADD\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SUB\"] = 519] = \"Z3_OP_SUB\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_UMINUS\"] = 520] = \"Z3_OP_UMINUS\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_MUL\"] = 521] = \"Z3_OP_MUL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_DIV\"] = 522] = \"Z3_OP_DIV\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_IDIV\"] = 523] = \"Z3_OP_IDIV\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_REM\"] = 524] = \"Z3_OP_REM\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_MOD\"] = 525] = \"Z3_OP_MOD\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_TO_REAL\"] = 526] = \"Z3_OP_TO_REAL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_TO_INT\"] = 527] = \"Z3_OP_TO_INT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_IS_INT\"] = 528] = \"Z3_OP_IS_INT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_POWER\"] = 529] = \"Z3_OP_POWER\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_STORE\"] = 768] = \"Z3_OP_STORE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SELECT\"] = 769] = \"Z3_OP_SELECT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_CONST_ARRAY\"] = 770] = \"Z3_OP_CONST_ARRAY\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_ARRAY_MAP\"] = 771] = \"Z3_OP_ARRAY_MAP\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_ARRAY_DEFAULT\"] = 772] = \"Z3_OP_ARRAY_DEFAULT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SET_UNION\"] = 773] = \"Z3_OP_SET_UNION\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SET_INTERSECT\"] = 774] = \"Z3_OP_SET_INTERSECT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SET_DIFFERENCE\"] = 775] = \"Z3_OP_SET_DIFFERENCE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SET_COMPLEMENT\"] = 776] = \"Z3_OP_SET_COMPLEMENT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SET_SUBSET\"] = 777] = \"Z3_OP_SET_SUBSET\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_AS_ARRAY\"] = 778] = \"Z3_OP_AS_ARRAY\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_ARRAY_EXT\"] = 779] = \"Z3_OP_ARRAY_EXT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SET_HAS_SIZE\"] = 780] = \"Z3_OP_SET_HAS_SIZE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SET_CARD\"] = 781] = \"Z3_OP_SET_CARD\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BNUM\"] = 1024] = \"Z3_OP_BNUM\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BIT1\"] = 1025] = \"Z3_OP_BIT1\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BIT0\"] = 1026] = \"Z3_OP_BIT0\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BNEG\"] = 1027] = \"Z3_OP_BNEG\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BADD\"] = 1028] = \"Z3_OP_BADD\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BSUB\"] = 1029] = \"Z3_OP_BSUB\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BMUL\"] = 1030] = \"Z3_OP_BMUL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BSDIV\"] = 1031] = \"Z3_OP_BSDIV\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BUDIV\"] = 1032] = \"Z3_OP_BUDIV\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BSREM\"] = 1033] = \"Z3_OP_BSREM\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BUREM\"] = 1034] = \"Z3_OP_BUREM\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BSMOD\"] = 1035] = \"Z3_OP_BSMOD\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BSDIV0\"] = 1036] = \"Z3_OP_BSDIV0\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BUDIV0\"] = 1037] = \"Z3_OP_BUDIV0\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BSREM0\"] = 1038] = \"Z3_OP_BSREM0\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BUREM0\"] = 1039] = \"Z3_OP_BUREM0\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BSMOD0\"] = 1040] = \"Z3_OP_BSMOD0\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_ULEQ\"] = 1041] = \"Z3_OP_ULEQ\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SLEQ\"] = 1042] = \"Z3_OP_SLEQ\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_UGEQ\"] = 1043] = \"Z3_OP_UGEQ\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SGEQ\"] = 1044] = \"Z3_OP_SGEQ\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_ULT\"] = 1045] = \"Z3_OP_ULT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SLT\"] = 1046] = \"Z3_OP_SLT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_UGT\"] = 1047] = \"Z3_OP_UGT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SGT\"] = 1048] = \"Z3_OP_SGT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BAND\"] = 1049] = \"Z3_OP_BAND\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BOR\"] = 1050] = \"Z3_OP_BOR\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BNOT\"] = 1051] = \"Z3_OP_BNOT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BXOR\"] = 1052] = \"Z3_OP_BXOR\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BNAND\"] = 1053] = \"Z3_OP_BNAND\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BNOR\"] = 1054] = \"Z3_OP_BNOR\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BXNOR\"] = 1055] = \"Z3_OP_BXNOR\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_CONCAT\"] = 1056] = \"Z3_OP_CONCAT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SIGN_EXT\"] = 1057] = \"Z3_OP_SIGN_EXT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_ZERO_EXT\"] = 1058] = \"Z3_OP_ZERO_EXT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_EXTRACT\"] = 1059] = \"Z3_OP_EXTRACT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_REPEAT\"] = 1060] = \"Z3_OP_REPEAT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BREDOR\"] = 1061] = \"Z3_OP_BREDOR\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BREDAND\"] = 1062] = \"Z3_OP_BREDAND\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BCOMP\"] = 1063] = \"Z3_OP_BCOMP\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BSHL\"] = 1064] = \"Z3_OP_BSHL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BLSHR\"] = 1065] = \"Z3_OP_BLSHR\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BASHR\"] = 1066] = \"Z3_OP_BASHR\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_ROTATE_LEFT\"] = 1067] = \"Z3_OP_ROTATE_LEFT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_ROTATE_RIGHT\"] = 1068] = \"Z3_OP_ROTATE_RIGHT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_EXT_ROTATE_LEFT\"] = 1069] = \"Z3_OP_EXT_ROTATE_LEFT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_EXT_ROTATE_RIGHT\"] = 1070] = \"Z3_OP_EXT_ROTATE_RIGHT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BIT2BOOL\"] = 1071] = \"Z3_OP_BIT2BOOL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_INT2BV\"] = 1072] = \"Z3_OP_INT2BV\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BV2INT\"] = 1073] = \"Z3_OP_BV2INT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_CARRY\"] = 1074] = \"Z3_OP_CARRY\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_XOR3\"] = 1075] = \"Z3_OP_XOR3\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BSMUL_NO_OVFL\"] = 1076] = \"Z3_OP_BSMUL_NO_OVFL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BUMUL_NO_OVFL\"] = 1077] = \"Z3_OP_BUMUL_NO_OVFL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BSMUL_NO_UDFL\"] = 1078] = \"Z3_OP_BSMUL_NO_UDFL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BSDIV_I\"] = 1079] = \"Z3_OP_BSDIV_I\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BUDIV_I\"] = 1080] = \"Z3_OP_BUDIV_I\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BSREM_I\"] = 1081] = \"Z3_OP_BSREM_I\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BUREM_I\"] = 1082] = \"Z3_OP_BUREM_I\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_BSMOD_I\"] = 1083] = \"Z3_OP_BSMOD_I\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_UNDEF\"] = 1280] = \"Z3_OP_PR_UNDEF\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_TRUE\"] = 1281] = \"Z3_OP_PR_TRUE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_ASSERTED\"] = 1282] = \"Z3_OP_PR_ASSERTED\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_GOAL\"] = 1283] = \"Z3_OP_PR_GOAL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_MODUS_PONENS\"] = 1284] = \"Z3_OP_PR_MODUS_PONENS\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_REFLEXIVITY\"] = 1285] = \"Z3_OP_PR_REFLEXIVITY\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_SYMMETRY\"] = 1286] = \"Z3_OP_PR_SYMMETRY\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_TRANSITIVITY\"] = 1287] = \"Z3_OP_PR_TRANSITIVITY\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_TRANSITIVITY_STAR\"] = 1288] = \"Z3_OP_PR_TRANSITIVITY_STAR\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_MONOTONICITY\"] = 1289] = \"Z3_OP_PR_MONOTONICITY\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_QUANT_INTRO\"] = 1290] = \"Z3_OP_PR_QUANT_INTRO\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_BIND\"] = 1291] = \"Z3_OP_PR_BIND\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_DISTRIBUTIVITY\"] = 1292] = \"Z3_OP_PR_DISTRIBUTIVITY\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_AND_ELIM\"] = 1293] = \"Z3_OP_PR_AND_ELIM\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_NOT_OR_ELIM\"] = 1294] = \"Z3_OP_PR_NOT_OR_ELIM\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_REWRITE\"] = 1295] = \"Z3_OP_PR_REWRITE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_REWRITE_STAR\"] = 1296] = \"Z3_OP_PR_REWRITE_STAR\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_PULL_QUANT\"] = 1297] = \"Z3_OP_PR_PULL_QUANT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_PUSH_QUANT\"] = 1298] = \"Z3_OP_PR_PUSH_QUANT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_ELIM_UNUSED_VARS\"] = 1299] = \"Z3_OP_PR_ELIM_UNUSED_VARS\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_DER\"] = 1300] = \"Z3_OP_PR_DER\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_QUANT_INST\"] = 1301] = \"Z3_OP_PR_QUANT_INST\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_HYPOTHESIS\"] = 1302] = \"Z3_OP_PR_HYPOTHESIS\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_LEMMA\"] = 1303] = \"Z3_OP_PR_LEMMA\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_UNIT_RESOLUTION\"] = 1304] = \"Z3_OP_PR_UNIT_RESOLUTION\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_IFF_TRUE\"] = 1305] = \"Z3_OP_PR_IFF_TRUE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_IFF_FALSE\"] = 1306] = \"Z3_OP_PR_IFF_FALSE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_COMMUTATIVITY\"] = 1307] = \"Z3_OP_PR_COMMUTATIVITY\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_DEF_AXIOM\"] = 1308] = \"Z3_OP_PR_DEF_AXIOM\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_ASSUMPTION_ADD\"] = 1309] = \"Z3_OP_PR_ASSUMPTION_ADD\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_LEMMA_ADD\"] = 1310] = \"Z3_OP_PR_LEMMA_ADD\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_REDUNDANT_DEL\"] = 1311] = \"Z3_OP_PR_REDUNDANT_DEL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_CLAUSE_TRAIL\"] = 1312] = \"Z3_OP_PR_CLAUSE_TRAIL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_DEF_INTRO\"] = 1313] = \"Z3_OP_PR_DEF_INTRO\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_APPLY_DEF\"] = 1314] = \"Z3_OP_PR_APPLY_DEF\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_IFF_OEQ\"] = 1315] = \"Z3_OP_PR_IFF_OEQ\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_NNF_POS\"] = 1316] = \"Z3_OP_PR_NNF_POS\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_NNF_NEG\"] = 1317] = \"Z3_OP_PR_NNF_NEG\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_SKOLEMIZE\"] = 1318] = \"Z3_OP_PR_SKOLEMIZE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_MODUS_PONENS_OEQ\"] = 1319] = \"Z3_OP_PR_MODUS_PONENS_OEQ\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_TH_LEMMA\"] = 1320] = \"Z3_OP_PR_TH_LEMMA\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PR_HYPER_RESOLVE\"] = 1321] = \"Z3_OP_PR_HYPER_RESOLVE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RA_STORE\"] = 1536] = \"Z3_OP_RA_STORE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RA_EMPTY\"] = 1537] = \"Z3_OP_RA_EMPTY\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RA_IS_EMPTY\"] = 1538] = \"Z3_OP_RA_IS_EMPTY\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RA_JOIN\"] = 1539] = \"Z3_OP_RA_JOIN\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RA_UNION\"] = 1540] = \"Z3_OP_RA_UNION\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RA_WIDEN\"] = 1541] = \"Z3_OP_RA_WIDEN\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RA_PROJECT\"] = 1542] = \"Z3_OP_RA_PROJECT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RA_FILTER\"] = 1543] = \"Z3_OP_RA_FILTER\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RA_NEGATION_FILTER\"] = 1544] = \"Z3_OP_RA_NEGATION_FILTER\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RA_RENAME\"] = 1545] = \"Z3_OP_RA_RENAME\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RA_COMPLEMENT\"] = 1546] = \"Z3_OP_RA_COMPLEMENT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RA_SELECT\"] = 1547] = \"Z3_OP_RA_SELECT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RA_CLONE\"] = 1548] = \"Z3_OP_RA_CLONE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FD_CONSTANT\"] = 1549] = \"Z3_OP_FD_CONSTANT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FD_LT\"] = 1550] = \"Z3_OP_FD_LT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SEQ_UNIT\"] = 1551] = \"Z3_OP_SEQ_UNIT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SEQ_EMPTY\"] = 1552] = \"Z3_OP_SEQ_EMPTY\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SEQ_CONCAT\"] = 1553] = \"Z3_OP_SEQ_CONCAT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SEQ_PREFIX\"] = 1554] = \"Z3_OP_SEQ_PREFIX\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SEQ_SUFFIX\"] = 1555] = \"Z3_OP_SEQ_SUFFIX\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SEQ_CONTAINS\"] = 1556] = \"Z3_OP_SEQ_CONTAINS\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SEQ_EXTRACT\"] = 1557] = \"Z3_OP_SEQ_EXTRACT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SEQ_REPLACE\"] = 1558] = \"Z3_OP_SEQ_REPLACE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SEQ_REPLACE_RE\"] = 1559] = \"Z3_OP_SEQ_REPLACE_RE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SEQ_REPLACE_RE_ALL\"] = 1560] = \"Z3_OP_SEQ_REPLACE_RE_ALL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SEQ_REPLACE_ALL\"] = 1561] = \"Z3_OP_SEQ_REPLACE_ALL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SEQ_AT\"] = 1562] = \"Z3_OP_SEQ_AT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SEQ_NTH\"] = 1563] = \"Z3_OP_SEQ_NTH\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SEQ_LENGTH\"] = 1564] = \"Z3_OP_SEQ_LENGTH\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SEQ_INDEX\"] = 1565] = \"Z3_OP_SEQ_INDEX\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SEQ_LAST_INDEX\"] = 1566] = \"Z3_OP_SEQ_LAST_INDEX\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SEQ_TO_RE\"] = 1567] = \"Z3_OP_SEQ_TO_RE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SEQ_IN_RE\"] = 1568] = \"Z3_OP_SEQ_IN_RE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_STR_TO_INT\"] = 1569] = \"Z3_OP_STR_TO_INT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_INT_TO_STR\"] = 1570] = \"Z3_OP_INT_TO_STR\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_UBV_TO_STR\"] = 1571] = \"Z3_OP_UBV_TO_STR\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SBV_TO_STR\"] = 1572] = \"Z3_OP_SBV_TO_STR\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_STR_TO_CODE\"] = 1573] = \"Z3_OP_STR_TO_CODE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_STR_FROM_CODE\"] = 1574] = \"Z3_OP_STR_FROM_CODE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_STRING_LT\"] = 1575] = \"Z3_OP_STRING_LT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_STRING_LE\"] = 1576] = \"Z3_OP_STRING_LE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RE_PLUS\"] = 1577] = \"Z3_OP_RE_PLUS\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RE_STAR\"] = 1578] = \"Z3_OP_RE_STAR\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RE_OPTION\"] = 1579] = \"Z3_OP_RE_OPTION\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RE_CONCAT\"] = 1580] = \"Z3_OP_RE_CONCAT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RE_UNION\"] = 1581] = \"Z3_OP_RE_UNION\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RE_RANGE\"] = 1582] = \"Z3_OP_RE_RANGE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RE_DIFF\"] = 1583] = \"Z3_OP_RE_DIFF\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RE_INTERSECT\"] = 1584] = \"Z3_OP_RE_INTERSECT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RE_LOOP\"] = 1585] = \"Z3_OP_RE_LOOP\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RE_POWER\"] = 1586] = \"Z3_OP_RE_POWER\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RE_COMPLEMENT\"] = 1587] = \"Z3_OP_RE_COMPLEMENT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RE_EMPTY_SET\"] = 1588] = \"Z3_OP_RE_EMPTY_SET\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RE_FULL_SET\"] = 1589] = \"Z3_OP_RE_FULL_SET\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RE_FULL_CHAR_SET\"] = 1590] = \"Z3_OP_RE_FULL_CHAR_SET\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RE_OF_PRED\"] = 1591] = \"Z3_OP_RE_OF_PRED\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RE_REVERSE\"] = 1592] = \"Z3_OP_RE_REVERSE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RE_DERIVATIVE\"] = 1593] = \"Z3_OP_RE_DERIVATIVE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_CHAR_CONST\"] = 1594] = \"Z3_OP_CHAR_CONST\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_CHAR_LE\"] = 1595] = \"Z3_OP_CHAR_LE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_CHAR_TO_INT\"] = 1596] = \"Z3_OP_CHAR_TO_INT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_CHAR_TO_BV\"] = 1597] = \"Z3_OP_CHAR_TO_BV\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_CHAR_FROM_BV\"] = 1598] = \"Z3_OP_CHAR_FROM_BV\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_CHAR_IS_DIGIT\"] = 1599] = \"Z3_OP_CHAR_IS_DIGIT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_LABEL\"] = 1792] = \"Z3_OP_LABEL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_LABEL_LIT\"] = 1793] = \"Z3_OP_LABEL_LIT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_DT_CONSTRUCTOR\"] = 2048] = \"Z3_OP_DT_CONSTRUCTOR\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_DT_RECOGNISER\"] = 2049] = \"Z3_OP_DT_RECOGNISER\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_DT_IS\"] = 2050] = \"Z3_OP_DT_IS\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_DT_ACCESSOR\"] = 2051] = \"Z3_OP_DT_ACCESSOR\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_DT_UPDATE_FIELD\"] = 2052] = \"Z3_OP_DT_UPDATE_FIELD\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PB_AT_MOST\"] = 2304] = \"Z3_OP_PB_AT_MOST\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PB_AT_LEAST\"] = 2305] = \"Z3_OP_PB_AT_LEAST\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PB_LE\"] = 2306] = \"Z3_OP_PB_LE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PB_GE\"] = 2307] = \"Z3_OP_PB_GE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_PB_EQ\"] = 2308] = \"Z3_OP_PB_EQ\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SPECIAL_RELATION_LO\"] = 40960] = \"Z3_OP_SPECIAL_RELATION_LO\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SPECIAL_RELATION_PO\"] = 40961] = \"Z3_OP_SPECIAL_RELATION_PO\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SPECIAL_RELATION_PLO\"] = 40962] = \"Z3_OP_SPECIAL_RELATION_PLO\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SPECIAL_RELATION_TO\"] = 40963] = \"Z3_OP_SPECIAL_RELATION_TO\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SPECIAL_RELATION_TC\"] = 40964] = \"Z3_OP_SPECIAL_RELATION_TC\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_SPECIAL_RELATION_TRC\"] = 40965] = \"Z3_OP_SPECIAL_RELATION_TRC\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_RM_NEAREST_TIES_TO_EVEN\"] = 45056] = \"Z3_OP_FPA_RM_NEAREST_TIES_TO_EVEN\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_RM_NEAREST_TIES_TO_AWAY\"] = 45057] = \"Z3_OP_FPA_RM_NEAREST_TIES_TO_AWAY\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_RM_TOWARD_POSITIVE\"] = 45058] = \"Z3_OP_FPA_RM_TOWARD_POSITIVE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_RM_TOWARD_NEGATIVE\"] = 45059] = \"Z3_OP_FPA_RM_TOWARD_NEGATIVE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_RM_TOWARD_ZERO\"] = 45060] = \"Z3_OP_FPA_RM_TOWARD_ZERO\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_NUM\"] = 45061] = \"Z3_OP_FPA_NUM\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_PLUS_INF\"] = 45062] = \"Z3_OP_FPA_PLUS_INF\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_MINUS_INF\"] = 45063] = \"Z3_OP_FPA_MINUS_INF\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_NAN\"] = 45064] = \"Z3_OP_FPA_NAN\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_PLUS_ZERO\"] = 45065] = \"Z3_OP_FPA_PLUS_ZERO\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_MINUS_ZERO\"] = 45066] = \"Z3_OP_FPA_MINUS_ZERO\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_ADD\"] = 45067] = \"Z3_OP_FPA_ADD\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_SUB\"] = 45068] = \"Z3_OP_FPA_SUB\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_NEG\"] = 45069] = \"Z3_OP_FPA_NEG\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_MUL\"] = 45070] = \"Z3_OP_FPA_MUL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_DIV\"] = 45071] = \"Z3_OP_FPA_DIV\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_REM\"] = 45072] = \"Z3_OP_FPA_REM\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_ABS\"] = 45073] = \"Z3_OP_FPA_ABS\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_MIN\"] = 45074] = \"Z3_OP_FPA_MIN\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_MAX\"] = 45075] = \"Z3_OP_FPA_MAX\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_FMA\"] = 45076] = \"Z3_OP_FPA_FMA\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_SQRT\"] = 45077] = \"Z3_OP_FPA_SQRT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_ROUND_TO_INTEGRAL\"] = 45078] = \"Z3_OP_FPA_ROUND_TO_INTEGRAL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_EQ\"] = 45079] = \"Z3_OP_FPA_EQ\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_LT\"] = 45080] = \"Z3_OP_FPA_LT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_GT\"] = 45081] = \"Z3_OP_FPA_GT\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_LE\"] = 45082] = \"Z3_OP_FPA_LE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_GE\"] = 45083] = \"Z3_OP_FPA_GE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_IS_NAN\"] = 45084] = \"Z3_OP_FPA_IS_NAN\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_IS_INF\"] = 45085] = \"Z3_OP_FPA_IS_INF\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_IS_ZERO\"] = 45086] = \"Z3_OP_FPA_IS_ZERO\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_IS_NORMAL\"] = 45087] = \"Z3_OP_FPA_IS_NORMAL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_IS_SUBNORMAL\"] = 45088] = \"Z3_OP_FPA_IS_SUBNORMAL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_IS_NEGATIVE\"] = 45089] = \"Z3_OP_FPA_IS_NEGATIVE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_IS_POSITIVE\"] = 45090] = \"Z3_OP_FPA_IS_POSITIVE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_FP\"] = 45091] = \"Z3_OP_FPA_FP\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_TO_FP\"] = 45092] = \"Z3_OP_FPA_TO_FP\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_TO_FP_UNSIGNED\"] = 45093] = \"Z3_OP_FPA_TO_FP_UNSIGNED\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_TO_UBV\"] = 45094] = \"Z3_OP_FPA_TO_UBV\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_TO_SBV\"] = 45095] = \"Z3_OP_FPA_TO_SBV\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_TO_REAL\"] = 45096] = \"Z3_OP_FPA_TO_REAL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_TO_IEEE_BV\"] = 45097] = \"Z3_OP_FPA_TO_IEEE_BV\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_BVWRAP\"] = 45098] = \"Z3_OP_FPA_BVWRAP\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_FPA_BV2RM\"] = 45099] = \"Z3_OP_FPA_BV2RM\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_INTERNAL\"] = 45100] = \"Z3_OP_INTERNAL\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_RECURSIVE\"] = 45101] = \"Z3_OP_RECURSIVE\";\n    Z3_decl_kind[Z3_decl_kind[\"Z3_OP_UNINTERPRETED\"] = 45102] = \"Z3_OP_UNINTERPRETED\";\n})(Z3_decl_kind = exports.Z3_decl_kind || (exports.Z3_decl_kind = {}));\nvar Z3_param_kind;\n(function (Z3_param_kind) {\n    Z3_param_kind[Z3_param_kind[\"Z3_PK_UINT\"] = 0] = \"Z3_PK_UINT\";\n    Z3_param_kind[Z3_param_kind[\"Z3_PK_BOOL\"] = 1] = \"Z3_PK_BOOL\";\n    Z3_param_kind[Z3_param_kind[\"Z3_PK_DOUBLE\"] = 2] = \"Z3_PK_DOUBLE\";\n    Z3_param_kind[Z3_param_kind[\"Z3_PK_SYMBOL\"] = 3] = \"Z3_PK_SYMBOL\";\n    Z3_param_kind[Z3_param_kind[\"Z3_PK_STRING\"] = 4] = \"Z3_PK_STRING\";\n    Z3_param_kind[Z3_param_kind[\"Z3_PK_OTHER\"] = 5] = \"Z3_PK_OTHER\";\n    Z3_param_kind[Z3_param_kind[\"Z3_PK_INVALID\"] = 6] = \"Z3_PK_INVALID\";\n})(Z3_param_kind = exports.Z3_param_kind || (exports.Z3_param_kind = {}));\nvar Z3_ast_print_mode;\n(function (Z3_ast_print_mode) {\n    Z3_ast_print_mode[Z3_ast_print_mode[\"Z3_PRINT_SMTLIB_FULL\"] = 0] = \"Z3_PRINT_SMTLIB_FULL\";\n    Z3_ast_print_mode[Z3_ast_print_mode[\"Z3_PRINT_LOW_LEVEL\"] = 1] = \"Z3_PRINT_LOW_LEVEL\";\n    Z3_ast_print_mode[Z3_ast_print_mode[\"Z3_PRINT_SMTLIB2_COMPLIANT\"] = 2] = \"Z3_PRINT_SMTLIB2_COMPLIANT\";\n})(Z3_ast_print_mode = exports.Z3_ast_print_mode || (exports.Z3_ast_print_mode = {}));\nvar Z3_error_code;\n(function (Z3_error_code) {\n    Z3_error_code[Z3_error_code[\"Z3_OK\"] = 0] = \"Z3_OK\";\n    Z3_error_code[Z3_error_code[\"Z3_SORT_ERROR\"] = 1] = \"Z3_SORT_ERROR\";\n    Z3_error_code[Z3_error_code[\"Z3_IOB\"] = 2] = \"Z3_IOB\";\n    Z3_error_code[Z3_error_code[\"Z3_INVALID_ARG\"] = 3] = \"Z3_INVALID_ARG\";\n    Z3_error_code[Z3_error_code[\"Z3_PARSER_ERROR\"] = 4] = \"Z3_PARSER_ERROR\";\n    Z3_error_code[Z3_error_code[\"Z3_NO_PARSER\"] = 5] = \"Z3_NO_PARSER\";\n    Z3_error_code[Z3_error_code[\"Z3_INVALID_PATTERN\"] = 6] = \"Z3_INVALID_PATTERN\";\n    Z3_error_code[Z3_error_code[\"Z3_MEMOUT_FAIL\"] = 7] = \"Z3_MEMOUT_FAIL\";\n    Z3_error_code[Z3_error_code[\"Z3_FILE_ACCESS_ERROR\"] = 8] = \"Z3_FILE_ACCESS_ERROR\";\n    Z3_error_code[Z3_error_code[\"Z3_INTERNAL_FATAL\"] = 9] = \"Z3_INTERNAL_FATAL\";\n    Z3_error_code[Z3_error_code[\"Z3_INVALID_USAGE\"] = 10] = \"Z3_INVALID_USAGE\";\n    Z3_error_code[Z3_error_code[\"Z3_DEC_REF_ERROR\"] = 11] = \"Z3_DEC_REF_ERROR\";\n    Z3_error_code[Z3_error_code[\"Z3_EXCEPTION\"] = 12] = \"Z3_EXCEPTION\";\n})(Z3_error_code = exports.Z3_error_code || (exports.Z3_error_code = {}));\nvar Z3_goal_prec;\n(function (Z3_goal_prec) {\n    Z3_goal_prec[Z3_goal_prec[\"Z3_GOAL_PRECISE\"] = 0] = \"Z3_GOAL_PRECISE\";\n    Z3_goal_prec[Z3_goal_prec[\"Z3_GOAL_UNDER\"] = 1] = \"Z3_GOAL_UNDER\";\n    Z3_goal_prec[Z3_goal_prec[\"Z3_GOAL_OVER\"] = 2] = \"Z3_GOAL_OVER\";\n    Z3_goal_prec[Z3_goal_prec[\"Z3_GOAL_UNDER_OVER\"] = 3] = \"Z3_GOAL_UNDER_OVER\";\n})(Z3_goal_prec = exports.Z3_goal_prec || (exports.Z3_goal_prec = {}));\n\n\n//# sourceURL=webpack:///./node_modules/z3-solver/build/low-level/types.__GENERATED__.js?");

/***/ }),

/***/ "./node_modules/z3-solver/build/low-level/wrapper.__GENERATED__.js":
/*!*************************************************************************!*\
  !*** ./node_modules/z3-solver/build/low-level/wrapper.__GENERATED__.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// THIS FILE IS AUTOMATICALLY GENERATED BY make-ts-wrapper.ts\n// DO NOT EDIT IT BY HAND\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nasync function init(initModule) {\n    let Mod = await initModule();\n    // this works for both signed and unsigned, because JS will wrap for you when constructing the Uint32Array\n    function intArrayToByteArr(ints) {\n        return new Uint8Array(new Uint32Array(ints).buffer);\n    }\n    function boolArrayToByteArr(bools) {\n        return bools.map((b) => (b ? 1 : 0));\n    }\n    function readUintArray(address, count) {\n        return Array.from(new Uint32Array(Mod.HEAPU32.buffer, address, count));\n    }\n    let outAddress = Mod._malloc(24);\n    let outUintArray = new Uint32Array(Mod.HEAPU32.buffer, outAddress, 4);\n    let getOutUint = (i) => outUintArray[i];\n    let outIntArray = new Int32Array(Mod.HEAPU32.buffer, outAddress, 4);\n    let getOutInt = (i) => outIntArray[i];\n    let outUint64Array = new BigUint64Array(Mod.HEAPU32.buffer, outAddress, 2);\n    let getOutUint64 = (i) => outUint64Array[i];\n    let outInt64Array = new BigInt64Array(Mod.HEAPU32.buffer, outAddress, 2);\n    let getOutInt64 = (i) => outInt64Array[i];\n    return {\n        em: Mod,\n        Z3: {\n            mk_context: function (c) {\n                let ctx = Mod._Z3_mk_context(c);\n                Mod._set_noop_error_handler(ctx);\n                return ctx;\n            },\n            mk_context_rc: function (c) {\n                let ctx = Mod._Z3_mk_context_rc(c);\n                Mod._set_noop_error_handler(ctx);\n                return ctx;\n            },\n            global_param_set: function (param_id, param_value) {\n                return Mod.ccall('Z3_global_param_set', 'void', ['string', 'string'], [param_id, param_value]);\n            },\n            global_param_reset_all: Mod._Z3_global_param_reset_all,\n            global_param_get: function (param_id) {\n                let ret = Mod.ccall('Z3_global_param_get', 'boolean', ['string', 'number'], [param_id, outAddress]);\n                if (!ret) {\n                    return null;\n                }\n                return Mod.UTF8ToString(getOutUint(0));\n            },\n            mk_config: Mod._Z3_mk_config,\n            del_config: Mod._Z3_del_config,\n            set_param_value: function (c, param_id, param_value) {\n                return Mod.ccall('Z3_set_param_value', 'void', ['number', 'string', 'string'], [c, param_id, param_value]);\n            },\n            del_context: Mod._Z3_del_context,\n            inc_ref: Mod._Z3_inc_ref,\n            dec_ref: Mod._Z3_dec_ref,\n            update_param_value: function (c, param_id, param_value) {\n                return Mod.ccall('Z3_update_param_value', 'void', ['number', 'string', 'string'], [c, param_id, param_value]);\n            },\n            get_global_param_descrs: Mod._Z3_get_global_param_descrs,\n            interrupt: Mod._Z3_interrupt,\n            mk_params: Mod._Z3_mk_params,\n            params_inc_ref: Mod._Z3_params_inc_ref,\n            params_dec_ref: Mod._Z3_params_dec_ref,\n            params_set_bool: Mod._Z3_params_set_bool,\n            params_set_uint: Mod._Z3_params_set_uint,\n            params_set_double: Mod._Z3_params_set_double,\n            params_set_symbol: Mod._Z3_params_set_symbol,\n            params_to_string: function (c, p) {\n                return Mod.ccall('Z3_params_to_string', 'string', ['number', 'number'], [c, p]);\n            },\n            params_validate: Mod._Z3_params_validate,\n            param_descrs_inc_ref: Mod._Z3_param_descrs_inc_ref,\n            param_descrs_dec_ref: Mod._Z3_param_descrs_dec_ref,\n            param_descrs_get_kind: Mod._Z3_param_descrs_get_kind,\n            param_descrs_size: Mod._Z3_param_descrs_size,\n            param_descrs_get_name: Mod._Z3_param_descrs_get_name,\n            param_descrs_get_documentation: function (c, p, s) {\n                return Mod.ccall('Z3_param_descrs_get_documentation', 'string', ['number', 'number', 'number'], [c, p, s]);\n            },\n            param_descrs_to_string: function (c, p) {\n                return Mod.ccall('Z3_param_descrs_to_string', 'string', ['number', 'number'], [c, p]);\n            },\n            mk_int_symbol: Mod._Z3_mk_int_symbol,\n            mk_string_symbol: function (c, s) {\n                return Mod.ccall('Z3_mk_string_symbol', 'number', ['number', 'string'], [c, s]);\n            },\n            mk_uninterpreted_sort: Mod._Z3_mk_uninterpreted_sort,\n            mk_bool_sort: Mod._Z3_mk_bool_sort,\n            mk_int_sort: Mod._Z3_mk_int_sort,\n            mk_real_sort: Mod._Z3_mk_real_sort,\n            mk_bv_sort: Mod._Z3_mk_bv_sort,\n            mk_finite_domain_sort: Mod._Z3_mk_finite_domain_sort,\n            mk_array_sort: Mod._Z3_mk_array_sort,\n            mk_array_sort_n: function (c, domain, range) {\n                return Mod.ccall('Z3_mk_array_sort_n', 'number', ['number', 'number', 'array', 'number'], [\n                    c,\n                    domain.length,\n                    intArrayToByteArr(domain),\n                    range,\n                ]);\n            },\n            mk_tuple_sort: function (c, mk_tuple_name, field_names, field_sorts) {\n                if (field_names.length !== field_sorts.length) {\n                    throw new TypeError(`field_names and field_sorts must be the same length (got ${field_names.length} and {field_sorts.length})`);\n                }\n                let outArray_proj_decl = Mod._malloc(4 * field_names.length);\n                try {\n                    let ret = Mod.ccall('Z3_mk_tuple_sort', 'number', [\n                        'number',\n                        'number',\n                        'number',\n                        'array',\n                        'array',\n                        'number',\n                        'number',\n                    ], [\n                        c,\n                        mk_tuple_name,\n                        field_names.length,\n                        intArrayToByteArr(field_names),\n                        intArrayToByteArr(field_sorts),\n                        outAddress,\n                        outArray_proj_decl,\n                    ]);\n                    return {\n                        rv: ret,\n                        mk_tuple_decl: getOutUint(0),\n                        proj_decl: readUintArray(outArray_proj_decl, field_names.length),\n                    };\n                }\n                finally {\n                    Mod._free(outArray_proj_decl);\n                }\n            },\n            mk_enumeration_sort: function (c, name, enum_names) {\n                let outArray_enum_consts = Mod._malloc(4 * enum_names.length);\n                try {\n                    let outArray_enum_testers = Mod._malloc(4 * enum_names.length);\n                    try {\n                        let ret = Mod.ccall('Z3_mk_enumeration_sort', 'number', ['number', 'number', 'number', 'array', 'number', 'number'], [\n                            c,\n                            name,\n                            enum_names.length,\n                            intArrayToByteArr(enum_names),\n                            outArray_enum_consts,\n                            outArray_enum_testers,\n                        ]);\n                        return {\n                            rv: ret,\n                            enum_consts: readUintArray(outArray_enum_consts, enum_names.length),\n                            enum_testers: readUintArray(outArray_enum_testers, enum_names.length),\n                        };\n                    }\n                    finally {\n                        Mod._free(outArray_enum_testers);\n                    }\n                }\n                finally {\n                    Mod._free(outArray_enum_consts);\n                }\n            },\n            mk_list_sort: function (c, name, elem_sort) {\n                let ret = Mod.ccall('Z3_mk_list_sort', 'number', [\n                    'number',\n                    'number',\n                    'number',\n                    'number',\n                    'number',\n                    'number',\n                    'number',\n                    'number',\n                    'number',\n                ], [\n                    c,\n                    name,\n                    elem_sort,\n                    outAddress,\n                    outAddress + 4,\n                    outAddress + 8,\n                    outAddress + 12,\n                    outAddress + 16,\n                    outAddress + 20,\n                ]);\n                return {\n                    rv: ret,\n                    nil_decl: getOutUint(0),\n                    is_nil_decl: getOutUint(1),\n                    cons_decl: getOutUint(2),\n                    is_cons_decl: getOutUint(3),\n                    head_decl: getOutUint(4),\n                    tail_decl: getOutUint(5),\n                };\n            },\n            mk_constructor: function (c, name, recognizer, field_names, sorts, sort_refs) {\n                if (field_names.length !== sorts.length) {\n                    throw new TypeError(`field_names and sorts must be the same length (got ${field_names.length} and {sorts.length})`);\n                }\n                if (field_names.length !== sort_refs.length) {\n                    throw new TypeError(`field_names and sort_refs must be the same length (got ${field_names.length} and {sort_refs.length})`);\n                }\n                return Mod.ccall('Z3_mk_constructor', 'number', ['number', 'number', 'number', 'number', 'array', 'array', 'array'], [\n                    c,\n                    name,\n                    recognizer,\n                    field_names.length,\n                    intArrayToByteArr(field_names),\n                    intArrayToByteArr(sorts),\n                    intArrayToByteArr(sort_refs),\n                ]);\n            },\n            del_constructor: Mod._Z3_del_constructor,\n            mk_datatype: function (c, name, constructors) {\n                return Mod.ccall('Z3_mk_datatype', 'number', ['number', 'number', 'number', 'array'], [\n                    c,\n                    name,\n                    constructors.length,\n                    intArrayToByteArr(constructors),\n                ]);\n            },\n            mk_datatype_sort: Mod._Z3_mk_datatype_sort,\n            mk_constructor_list: function (c, constructors) {\n                return Mod.ccall('Z3_mk_constructor_list', 'number', ['number', 'number', 'array'], [\n                    c,\n                    constructors.length,\n                    intArrayToByteArr(constructors),\n                ]);\n            },\n            del_constructor_list: Mod._Z3_del_constructor_list,\n            mk_datatypes: function (c, sort_names, constructor_lists) {\n                if (sort_names.length !== constructor_lists.length) {\n                    throw new TypeError(`sort_names and constructor_lists must be the same length (got ${sort_names.length} and {constructor_lists.length})`);\n                }\n                let outArray_sorts = Mod._malloc(4 * sort_names.length);\n                try {\n                    let ret = Mod.ccall('Z3_mk_datatypes', 'void', ['number', 'number', 'array', 'number', 'array'], [\n                        c,\n                        sort_names.length,\n                        intArrayToByteArr(sort_names),\n                        outArray_sorts,\n                        intArrayToByteArr(constructor_lists),\n                    ]);\n                    return readUintArray(outArray_sorts, sort_names.length);\n                }\n                finally {\n                    Mod._free(outArray_sorts);\n                }\n            },\n            query_constructor: function (c, constr, num_fields) {\n                let outArray_accessors = Mod._malloc(4 * num_fields);\n                try {\n                    let ret = Mod.ccall('Z3_query_constructor', 'void', ['number', 'number', 'number', 'number', 'number', 'number'], [\n                        c,\n                        constr,\n                        num_fields,\n                        outAddress,\n                        outAddress + 4,\n                        outArray_accessors,\n                    ]);\n                    return {\n                        constructor: getOutUint(0),\n                        tester: getOutUint(1),\n                        accessors: readUintArray(outArray_accessors, num_fields),\n                    };\n                }\n                finally {\n                    Mod._free(outArray_accessors);\n                }\n            },\n            mk_func_decl: function (c, s, domain, range) {\n                return Mod.ccall('Z3_mk_func_decl', 'number', ['number', 'number', 'number', 'array', 'number'], [\n                    c,\n                    s,\n                    domain.length,\n                    intArrayToByteArr(domain),\n                    range,\n                ]);\n            },\n            mk_app: function (c, d, args) {\n                return Mod.ccall('Z3_mk_app', 'number', ['number', 'number', 'number', 'array'], [c, d, args.length, intArrayToByteArr(args)]);\n            },\n            mk_const: Mod._Z3_mk_const,\n            mk_fresh_func_decl: function (c, prefix, domain, range) {\n                return Mod.ccall('Z3_mk_fresh_func_decl', 'number', ['number', 'string', 'number', 'array', 'number'], [\n                    c,\n                    prefix,\n                    domain.length,\n                    intArrayToByteArr(domain),\n                    range,\n                ]);\n            },\n            mk_fresh_const: function (c, prefix, ty) {\n                return Mod.ccall('Z3_mk_fresh_const', 'number', ['number', 'string', 'number'], [c, prefix, ty]);\n            },\n            mk_rec_func_decl: function (c, s, domain, range) {\n                return Mod.ccall('Z3_mk_rec_func_decl', 'number', ['number', 'number', 'number', 'array', 'number'], [\n                    c,\n                    s,\n                    domain.length,\n                    intArrayToByteArr(domain),\n                    range,\n                ]);\n            },\n            add_rec_def: function (c, f, args, body) {\n                return Mod.ccall('Z3_add_rec_def', 'void', ['number', 'number', 'number', 'array', 'number'], [\n                    c,\n                    f,\n                    args.length,\n                    intArrayToByteArr(args),\n                    body,\n                ]);\n            },\n            mk_true: Mod._Z3_mk_true,\n            mk_false: Mod._Z3_mk_false,\n            mk_eq: Mod._Z3_mk_eq,\n            mk_distinct: function (c, args) {\n                return Mod.ccall('Z3_mk_distinct', 'number', ['number', 'number', 'array'], [c, args.length, intArrayToByteArr(args)]);\n            },\n            mk_not: Mod._Z3_mk_not,\n            mk_ite: Mod._Z3_mk_ite,\n            mk_iff: Mod._Z3_mk_iff,\n            mk_implies: Mod._Z3_mk_implies,\n            mk_xor: Mod._Z3_mk_xor,\n            mk_and: function (c, args) {\n                return Mod.ccall('Z3_mk_and', 'number', ['number', 'number', 'array'], [c, args.length, intArrayToByteArr(args)]);\n            },\n            mk_or: function (c, args) {\n                return Mod.ccall('Z3_mk_or', 'number', ['number', 'number', 'array'], [c, args.length, intArrayToByteArr(args)]);\n            },\n            mk_add: function (c, args) {\n                return Mod.ccall('Z3_mk_add', 'number', ['number', 'number', 'array'], [c, args.length, intArrayToByteArr(args)]);\n            },\n            mk_mul: function (c, args) {\n                return Mod.ccall('Z3_mk_mul', 'number', ['number', 'number', 'array'], [c, args.length, intArrayToByteArr(args)]);\n            },\n            mk_sub: function (c, args) {\n                return Mod.ccall('Z3_mk_sub', 'number', ['number', 'number', 'array'], [c, args.length, intArrayToByteArr(args)]);\n            },\n            mk_unary_minus: Mod._Z3_mk_unary_minus,\n            mk_div: Mod._Z3_mk_div,\n            mk_mod: Mod._Z3_mk_mod,\n            mk_rem: Mod._Z3_mk_rem,\n            mk_power: Mod._Z3_mk_power,\n            mk_lt: Mod._Z3_mk_lt,\n            mk_le: Mod._Z3_mk_le,\n            mk_gt: Mod._Z3_mk_gt,\n            mk_ge: Mod._Z3_mk_ge,\n            mk_divides: Mod._Z3_mk_divides,\n            mk_int2real: Mod._Z3_mk_int2real,\n            mk_real2int: Mod._Z3_mk_real2int,\n            mk_is_int: Mod._Z3_mk_is_int,\n            mk_bvnot: Mod._Z3_mk_bvnot,\n            mk_bvredand: Mod._Z3_mk_bvredand,\n            mk_bvredor: Mod._Z3_mk_bvredor,\n            mk_bvand: Mod._Z3_mk_bvand,\n            mk_bvor: Mod._Z3_mk_bvor,\n            mk_bvxor: Mod._Z3_mk_bvxor,\n            mk_bvnand: Mod._Z3_mk_bvnand,\n            mk_bvnor: Mod._Z3_mk_bvnor,\n            mk_bvxnor: Mod._Z3_mk_bvxnor,\n            mk_bvneg: Mod._Z3_mk_bvneg,\n            mk_bvadd: Mod._Z3_mk_bvadd,\n            mk_bvsub: Mod._Z3_mk_bvsub,\n            mk_bvmul: Mod._Z3_mk_bvmul,\n            mk_bvudiv: Mod._Z3_mk_bvudiv,\n            mk_bvsdiv: Mod._Z3_mk_bvsdiv,\n            mk_bvurem: Mod._Z3_mk_bvurem,\n            mk_bvsrem: Mod._Z3_mk_bvsrem,\n            mk_bvsmod: Mod._Z3_mk_bvsmod,\n            mk_bvult: Mod._Z3_mk_bvult,\n            mk_bvslt: Mod._Z3_mk_bvslt,\n            mk_bvule: Mod._Z3_mk_bvule,\n            mk_bvsle: Mod._Z3_mk_bvsle,\n            mk_bvuge: Mod._Z3_mk_bvuge,\n            mk_bvsge: Mod._Z3_mk_bvsge,\n            mk_bvugt: Mod._Z3_mk_bvugt,\n            mk_bvsgt: Mod._Z3_mk_bvsgt,\n            mk_concat: Mod._Z3_mk_concat,\n            mk_extract: Mod._Z3_mk_extract,\n            mk_sign_ext: Mod._Z3_mk_sign_ext,\n            mk_zero_ext: Mod._Z3_mk_zero_ext,\n            mk_repeat: Mod._Z3_mk_repeat,\n            mk_bit2bool: Mod._Z3_mk_bit2bool,\n            mk_bvshl: Mod._Z3_mk_bvshl,\n            mk_bvlshr: Mod._Z3_mk_bvlshr,\n            mk_bvashr: Mod._Z3_mk_bvashr,\n            mk_rotate_left: Mod._Z3_mk_rotate_left,\n            mk_rotate_right: Mod._Z3_mk_rotate_right,\n            mk_ext_rotate_left: Mod._Z3_mk_ext_rotate_left,\n            mk_ext_rotate_right: Mod._Z3_mk_ext_rotate_right,\n            mk_int2bv: Mod._Z3_mk_int2bv,\n            mk_bv2int: Mod._Z3_mk_bv2int,\n            mk_bvadd_no_overflow: Mod._Z3_mk_bvadd_no_overflow,\n            mk_bvadd_no_underflow: Mod._Z3_mk_bvadd_no_underflow,\n            mk_bvsub_no_overflow: Mod._Z3_mk_bvsub_no_overflow,\n            mk_bvsub_no_underflow: Mod._Z3_mk_bvsub_no_underflow,\n            mk_bvsdiv_no_overflow: Mod._Z3_mk_bvsdiv_no_overflow,\n            mk_bvneg_no_overflow: Mod._Z3_mk_bvneg_no_overflow,\n            mk_bvmul_no_overflow: Mod._Z3_mk_bvmul_no_overflow,\n            mk_bvmul_no_underflow: Mod._Z3_mk_bvmul_no_underflow,\n            mk_select: Mod._Z3_mk_select,\n            mk_select_n: function (c, a, idxs) {\n                return Mod.ccall('Z3_mk_select_n', 'number', ['number', 'number', 'number', 'array'], [c, a, idxs.length, intArrayToByteArr(idxs)]);\n            },\n            mk_store: Mod._Z3_mk_store,\n            mk_store_n: function (c, a, idxs, v) {\n                return Mod.ccall('Z3_mk_store_n', 'number', ['number', 'number', 'number', 'array', 'number'], [c, a, idxs.length, intArrayToByteArr(idxs), v]);\n            },\n            mk_const_array: Mod._Z3_mk_const_array,\n            mk_map: function (c, f, args) {\n                return Mod.ccall('Z3_mk_map', 'number', ['number', 'number', 'number', 'array'], [c, f, args.length, intArrayToByteArr(args)]);\n            },\n            mk_array_default: Mod._Z3_mk_array_default,\n            mk_as_array: Mod._Z3_mk_as_array,\n            mk_set_has_size: Mod._Z3_mk_set_has_size,\n            mk_set_sort: Mod._Z3_mk_set_sort,\n            mk_empty_set: Mod._Z3_mk_empty_set,\n            mk_full_set: Mod._Z3_mk_full_set,\n            mk_set_add: Mod._Z3_mk_set_add,\n            mk_set_del: Mod._Z3_mk_set_del,\n            mk_set_union: function (c, args) {\n                return Mod.ccall('Z3_mk_set_union', 'number', ['number', 'number', 'array'], [c, args.length, intArrayToByteArr(args)]);\n            },\n            mk_set_intersect: function (c, args) {\n                return Mod.ccall('Z3_mk_set_intersect', 'number', ['number', 'number', 'array'], [c, args.length, intArrayToByteArr(args)]);\n            },\n            mk_set_difference: Mod._Z3_mk_set_difference,\n            mk_set_complement: Mod._Z3_mk_set_complement,\n            mk_set_member: Mod._Z3_mk_set_member,\n            mk_set_subset: Mod._Z3_mk_set_subset,\n            mk_array_ext: Mod._Z3_mk_array_ext,\n            mk_numeral: function (c, numeral, ty) {\n                return Mod.ccall('Z3_mk_numeral', 'number', ['number', 'string', 'number'], [c, numeral, ty]);\n            },\n            mk_real: Mod._Z3_mk_real,\n            mk_int: Mod._Z3_mk_int,\n            mk_unsigned_int: Mod._Z3_mk_unsigned_int,\n            mk_int64: Mod._Z3_mk_int64,\n            mk_unsigned_int64: Mod._Z3_mk_unsigned_int64,\n            mk_bv_numeral: function (c, bits) {\n                return Mod.ccall('Z3_mk_bv_numeral', 'number', ['number', 'number', 'array'], [c, bits.length, boolArrayToByteArr(bits)]);\n            },\n            mk_seq_sort: Mod._Z3_mk_seq_sort,\n            is_seq_sort: function (c, s) {\n                return Mod.ccall('Z3_is_seq_sort', 'boolean', ['number', 'number'], [c, s]);\n            },\n            get_seq_sort_basis: Mod._Z3_get_seq_sort_basis,\n            mk_re_sort: Mod._Z3_mk_re_sort,\n            is_re_sort: function (c, s) {\n                return Mod.ccall('Z3_is_re_sort', 'boolean', ['number', 'number'], [c, s]);\n            },\n            get_re_sort_basis: Mod._Z3_get_re_sort_basis,\n            mk_string_sort: Mod._Z3_mk_string_sort,\n            mk_char_sort: Mod._Z3_mk_char_sort,\n            is_string_sort: function (c, s) {\n                return Mod.ccall('Z3_is_string_sort', 'boolean', ['number', 'number'], [c, s]);\n            },\n            is_char_sort: function (c, s) {\n                return Mod.ccall('Z3_is_char_sort', 'boolean', ['number', 'number'], [c, s]);\n            },\n            mk_string: function (c, s) {\n                return Mod.ccall('Z3_mk_string', 'number', ['number', 'string'], [c, s]);\n            },\n            mk_lstring: function (c, len, s) {\n                return Mod.ccall('Z3_mk_lstring', 'number', ['number', 'number', 'string'], [c, len, s]);\n            },\n            mk_u32string: function (c, chars) {\n                return Mod.ccall('Z3_mk_u32string', 'number', ['number', 'number', 'array'], [c, chars.length, intArrayToByteArr(chars)]);\n            },\n            is_string: function (c, s) {\n                return Mod.ccall('Z3_is_string', 'boolean', ['number', 'number'], [c, s]);\n            },\n            get_string: function (c, s) {\n                return Mod.ccall('Z3_get_string', 'string', ['number', 'number'], [c, s]);\n            },\n            get_string_length: Mod._Z3_get_string_length,\n            get_string_contents: function (c, s, length) {\n                let outArray_contents = Mod._malloc(4 * length);\n                try {\n                    let ret = Mod.ccall('Z3_get_string_contents', 'void', ['number', 'number', 'number', 'number'], [c, s, length, outArray_contents]);\n                    return readUintArray(outArray_contents, length);\n                }\n                finally {\n                    Mod._free(outArray_contents);\n                }\n            },\n            mk_seq_empty: Mod._Z3_mk_seq_empty,\n            mk_seq_unit: Mod._Z3_mk_seq_unit,\n            mk_seq_concat: function (c, args) {\n                return Mod.ccall('Z3_mk_seq_concat', 'number', ['number', 'number', 'array'], [c, args.length, intArrayToByteArr(args)]);\n            },\n            mk_seq_prefix: Mod._Z3_mk_seq_prefix,\n            mk_seq_suffix: Mod._Z3_mk_seq_suffix,\n            mk_seq_contains: Mod._Z3_mk_seq_contains,\n            mk_str_lt: Mod._Z3_mk_str_lt,\n            mk_str_le: Mod._Z3_mk_str_le,\n            mk_seq_extract: Mod._Z3_mk_seq_extract,\n            mk_seq_replace: Mod._Z3_mk_seq_replace,\n            mk_seq_at: Mod._Z3_mk_seq_at,\n            mk_seq_nth: Mod._Z3_mk_seq_nth,\n            mk_seq_length: Mod._Z3_mk_seq_length,\n            mk_seq_index: Mod._Z3_mk_seq_index,\n            mk_seq_last_index: Mod._Z3_mk_seq_last_index,\n            mk_str_to_int: Mod._Z3_mk_str_to_int,\n            mk_int_to_str: Mod._Z3_mk_int_to_str,\n            mk_string_to_code: Mod._Z3_mk_string_to_code,\n            mk_string_from_code: Mod._Z3_mk_string_from_code,\n            mk_ubv_to_str: Mod._Z3_mk_ubv_to_str,\n            mk_sbv_to_str: Mod._Z3_mk_sbv_to_str,\n            mk_seq_to_re: Mod._Z3_mk_seq_to_re,\n            mk_seq_in_re: Mod._Z3_mk_seq_in_re,\n            mk_re_plus: Mod._Z3_mk_re_plus,\n            mk_re_star: Mod._Z3_mk_re_star,\n            mk_re_option: Mod._Z3_mk_re_option,\n            mk_re_union: function (c, args) {\n                return Mod.ccall('Z3_mk_re_union', 'number', ['number', 'number', 'array'], [c, args.length, intArrayToByteArr(args)]);\n            },\n            mk_re_concat: function (c, args) {\n                return Mod.ccall('Z3_mk_re_concat', 'number', ['number', 'number', 'array'], [c, args.length, intArrayToByteArr(args)]);\n            },\n            mk_re_range: Mod._Z3_mk_re_range,\n            mk_re_allchar: Mod._Z3_mk_re_allchar,\n            mk_re_loop: Mod._Z3_mk_re_loop,\n            mk_re_power: Mod._Z3_mk_re_power,\n            mk_re_intersect: function (c, args) {\n                return Mod.ccall('Z3_mk_re_intersect', 'number', ['number', 'number', 'array'], [c, args.length, intArrayToByteArr(args)]);\n            },\n            mk_re_complement: Mod._Z3_mk_re_complement,\n            mk_re_diff: Mod._Z3_mk_re_diff,\n            mk_re_empty: Mod._Z3_mk_re_empty,\n            mk_re_full: Mod._Z3_mk_re_full,\n            mk_char: Mod._Z3_mk_char,\n            mk_char_le: Mod._Z3_mk_char_le,\n            mk_char_to_int: Mod._Z3_mk_char_to_int,\n            mk_char_to_bv: Mod._Z3_mk_char_to_bv,\n            mk_char_from_bv: Mod._Z3_mk_char_from_bv,\n            mk_char_is_digit: Mod._Z3_mk_char_is_digit,\n            mk_linear_order: Mod._Z3_mk_linear_order,\n            mk_partial_order: Mod._Z3_mk_partial_order,\n            mk_piecewise_linear_order: Mod._Z3_mk_piecewise_linear_order,\n            mk_tree_order: Mod._Z3_mk_tree_order,\n            mk_transitive_closure: Mod._Z3_mk_transitive_closure,\n            mk_pattern: function (c, terms) {\n                return Mod.ccall('Z3_mk_pattern', 'number', ['number', 'number', 'array'], [c, terms.length, intArrayToByteArr(terms)]);\n            },\n            mk_bound: Mod._Z3_mk_bound,\n            mk_forall: function (c, weight, patterns, sorts, decl_names, body) {\n                if (sorts.length !== decl_names.length) {\n                    throw new TypeError(`sorts and decl_names must be the same length (got ${sorts.length} and {decl_names.length})`);\n                }\n                return Mod.ccall('Z3_mk_forall', 'number', [\n                    'number',\n                    'number',\n                    'number',\n                    'array',\n                    'number',\n                    'array',\n                    'array',\n                    'number',\n                ], [\n                    c,\n                    weight,\n                    patterns.length,\n                    intArrayToByteArr(patterns),\n                    sorts.length,\n                    intArrayToByteArr(sorts),\n                    intArrayToByteArr(decl_names),\n                    body,\n                ]);\n            },\n            mk_exists: function (c, weight, patterns, sorts, decl_names, body) {\n                if (sorts.length !== decl_names.length) {\n                    throw new TypeError(`sorts and decl_names must be the same length (got ${sorts.length} and {decl_names.length})`);\n                }\n                return Mod.ccall('Z3_mk_exists', 'number', [\n                    'number',\n                    'number',\n                    'number',\n                    'array',\n                    'number',\n                    'array',\n                    'array',\n                    'number',\n                ], [\n                    c,\n                    weight,\n                    patterns.length,\n                    intArrayToByteArr(patterns),\n                    sorts.length,\n                    intArrayToByteArr(sorts),\n                    intArrayToByteArr(decl_names),\n                    body,\n                ]);\n            },\n            mk_quantifier: function (c, is_forall, weight, patterns, sorts, decl_names, body) {\n                if (sorts.length !== decl_names.length) {\n                    throw new TypeError(`sorts and decl_names must be the same length (got ${sorts.length} and {decl_names.length})`);\n                }\n                return Mod.ccall('Z3_mk_quantifier', 'number', [\n                    'number',\n                    'boolean',\n                    'number',\n                    'number',\n                    'array',\n                    'number',\n                    'array',\n                    'array',\n                    'number',\n                ], [\n                    c,\n                    is_forall,\n                    weight,\n                    patterns.length,\n                    intArrayToByteArr(patterns),\n                    sorts.length,\n                    intArrayToByteArr(sorts),\n                    intArrayToByteArr(decl_names),\n                    body,\n                ]);\n            },\n            mk_quantifier_ex: function (c, is_forall, weight, quantifier_id, skolem_id, patterns, no_patterns, sorts, decl_names, body) {\n                if (sorts.length !== decl_names.length) {\n                    throw new TypeError(`sorts and decl_names must be the same length (got ${sorts.length} and {decl_names.length})`);\n                }\n                return Mod.ccall('Z3_mk_quantifier_ex', 'number', [\n                    'number',\n                    'boolean',\n                    'number',\n                    'number',\n                    'number',\n                    'number',\n                    'array',\n                    'number',\n                    'array',\n                    'number',\n                    'array',\n                    'array',\n                    'number',\n                ], [\n                    c,\n                    is_forall,\n                    weight,\n                    quantifier_id,\n                    skolem_id,\n                    patterns.length,\n                    intArrayToByteArr(patterns),\n                    no_patterns.length,\n                    intArrayToByteArr(no_patterns),\n                    sorts.length,\n                    intArrayToByteArr(sorts),\n                    intArrayToByteArr(decl_names),\n                    body,\n                ]);\n            },\n            mk_forall_const: function (c, weight, bound, patterns, body) {\n                return Mod.ccall('Z3_mk_forall_const', 'number', ['number', 'number', 'number', 'array', 'number', 'array', 'number'], [\n                    c,\n                    weight,\n                    bound.length,\n                    intArrayToByteArr(bound),\n                    patterns.length,\n                    intArrayToByteArr(patterns),\n                    body,\n                ]);\n            },\n            mk_exists_const: function (c, weight, bound, patterns, body) {\n                return Mod.ccall('Z3_mk_exists_const', 'number', ['number', 'number', 'number', 'array', 'number', 'array', 'number'], [\n                    c,\n                    weight,\n                    bound.length,\n                    intArrayToByteArr(bound),\n                    patterns.length,\n                    intArrayToByteArr(patterns),\n                    body,\n                ]);\n            },\n            mk_quantifier_const: function (c, is_forall, weight, bound, patterns, body) {\n                return Mod.ccall('Z3_mk_quantifier_const', 'number', [\n                    'number',\n                    'boolean',\n                    'number',\n                    'number',\n                    'array',\n                    'number',\n                    'array',\n                    'number',\n                ], [\n                    c,\n                    is_forall,\n                    weight,\n                    bound.length,\n                    intArrayToByteArr(bound),\n                    patterns.length,\n                    intArrayToByteArr(patterns),\n                    body,\n                ]);\n            },\n            mk_quantifier_const_ex: function (c, is_forall, weight, quantifier_id, skolem_id, bound, patterns, no_patterns, body) {\n                return Mod.ccall('Z3_mk_quantifier_const_ex', 'number', [\n                    'number',\n                    'boolean',\n                    'number',\n                    'number',\n                    'number',\n                    'number',\n                    'array',\n                    'number',\n                    'array',\n                    'number',\n                    'array',\n                    'number',\n                ], [\n                    c,\n                    is_forall,\n                    weight,\n                    quantifier_id,\n                    skolem_id,\n                    bound.length,\n                    intArrayToByteArr(bound),\n                    patterns.length,\n                    intArrayToByteArr(patterns),\n                    no_patterns.length,\n                    intArrayToByteArr(no_patterns),\n                    body,\n                ]);\n            },\n            mk_lambda: function (c, sorts, decl_names, body) {\n                if (sorts.length !== decl_names.length) {\n                    throw new TypeError(`sorts and decl_names must be the same length (got ${sorts.length} and {decl_names.length})`);\n                }\n                return Mod.ccall('Z3_mk_lambda', 'number', ['number', 'number', 'array', 'array', 'number'], [\n                    c,\n                    sorts.length,\n                    intArrayToByteArr(sorts),\n                    intArrayToByteArr(decl_names),\n                    body,\n                ]);\n            },\n            mk_lambda_const: function (c, bound, body) {\n                return Mod.ccall('Z3_mk_lambda_const', 'number', ['number', 'number', 'array', 'number'], [\n                    c,\n                    bound.length,\n                    intArrayToByteArr(bound),\n                    body,\n                ]);\n            },\n            get_symbol_kind: Mod._Z3_get_symbol_kind,\n            get_symbol_int: Mod._Z3_get_symbol_int,\n            get_symbol_string: function (c, s) {\n                return Mod.ccall('Z3_get_symbol_string', 'string', ['number', 'number'], [c, s]);\n            },\n            get_sort_name: Mod._Z3_get_sort_name,\n            get_sort_id: Mod._Z3_get_sort_id,\n            sort_to_ast: Mod._Z3_sort_to_ast,\n            is_eq_sort: function (c, s1, s2) {\n                return Mod.ccall('Z3_is_eq_sort', 'boolean', ['number', 'number', 'number'], [c, s1, s2]);\n            },\n            get_sort_kind: Mod._Z3_get_sort_kind,\n            get_bv_sort_size: Mod._Z3_get_bv_sort_size,\n            get_finite_domain_sort_size: function (c, s) {\n                let ret = Mod.ccall('Z3_get_finite_domain_sort_size', 'boolean', ['number', 'number', 'number'], [c, s, outAddress]);\n                if (!ret) {\n                    return null;\n                }\n                return getOutUint64(0);\n            },\n            get_array_sort_domain: Mod._Z3_get_array_sort_domain,\n            get_array_sort_domain_n: Mod._Z3_get_array_sort_domain_n,\n            get_array_sort_range: Mod._Z3_get_array_sort_range,\n            get_tuple_sort_mk_decl: Mod._Z3_get_tuple_sort_mk_decl,\n            get_tuple_sort_num_fields: Mod._Z3_get_tuple_sort_num_fields,\n            get_tuple_sort_field_decl: Mod._Z3_get_tuple_sort_field_decl,\n            get_datatype_sort_num_constructors: Mod._Z3_get_datatype_sort_num_constructors,\n            get_datatype_sort_constructor: Mod._Z3_get_datatype_sort_constructor,\n            get_datatype_sort_recognizer: Mod._Z3_get_datatype_sort_recognizer,\n            get_datatype_sort_constructor_accessor: Mod._Z3_get_datatype_sort_constructor_accessor,\n            datatype_update_field: Mod._Z3_datatype_update_field,\n            get_relation_arity: Mod._Z3_get_relation_arity,\n            get_relation_column: Mod._Z3_get_relation_column,\n            mk_atmost: function (c, args, k) {\n                return Mod.ccall('Z3_mk_atmost', 'number', ['number', 'number', 'array', 'number'], [c, args.length, intArrayToByteArr(args), k]);\n            },\n            mk_atleast: function (c, args, k) {\n                return Mod.ccall('Z3_mk_atleast', 'number', ['number', 'number', 'array', 'number'], [c, args.length, intArrayToByteArr(args), k]);\n            },\n            mk_pble: function (c, args, coeffs, k) {\n                if (args.length !== coeffs.length) {\n                    throw new TypeError(`args and coeffs must be the same length (got ${args.length} and {coeffs.length})`);\n                }\n                return Mod.ccall('Z3_mk_pble', 'number', ['number', 'number', 'array', 'array', 'number'], [\n                    c,\n                    args.length,\n                    intArrayToByteArr(args),\n                    intArrayToByteArr(coeffs),\n                    k,\n                ]);\n            },\n            mk_pbge: function (c, args, coeffs, k) {\n                if (args.length !== coeffs.length) {\n                    throw new TypeError(`args and coeffs must be the same length (got ${args.length} and {coeffs.length})`);\n                }\n                return Mod.ccall('Z3_mk_pbge', 'number', ['number', 'number', 'array', 'array', 'number'], [\n                    c,\n                    args.length,\n                    intArrayToByteArr(args),\n                    intArrayToByteArr(coeffs),\n                    k,\n                ]);\n            },\n            mk_pbeq: function (c, args, coeffs, k) {\n                if (args.length !== coeffs.length) {\n                    throw new TypeError(`args and coeffs must be the same length (got ${args.length} and {coeffs.length})`);\n                }\n                return Mod.ccall('Z3_mk_pbeq', 'number', ['number', 'number', 'array', 'array', 'number'], [\n                    c,\n                    args.length,\n                    intArrayToByteArr(args),\n                    intArrayToByteArr(coeffs),\n                    k,\n                ]);\n            },\n            func_decl_to_ast: Mod._Z3_func_decl_to_ast,\n            is_eq_func_decl: function (c, f1, f2) {\n                return Mod.ccall('Z3_is_eq_func_decl', 'boolean', ['number', 'number', 'number'], [c, f1, f2]);\n            },\n            get_func_decl_id: Mod._Z3_get_func_decl_id,\n            get_decl_name: Mod._Z3_get_decl_name,\n            get_decl_kind: Mod._Z3_get_decl_kind,\n            get_domain_size: Mod._Z3_get_domain_size,\n            get_arity: Mod._Z3_get_arity,\n            get_domain: Mod._Z3_get_domain,\n            get_range: Mod._Z3_get_range,\n            get_decl_num_parameters: Mod._Z3_get_decl_num_parameters,\n            get_decl_parameter_kind: Mod._Z3_get_decl_parameter_kind,\n            get_decl_int_parameter: Mod._Z3_get_decl_int_parameter,\n            get_decl_double_parameter: Mod._Z3_get_decl_double_parameter,\n            get_decl_symbol_parameter: Mod._Z3_get_decl_symbol_parameter,\n            get_decl_sort_parameter: Mod._Z3_get_decl_sort_parameter,\n            get_decl_ast_parameter: Mod._Z3_get_decl_ast_parameter,\n            get_decl_func_decl_parameter: Mod._Z3_get_decl_func_decl_parameter,\n            get_decl_rational_parameter: function (c, d, idx) {\n                return Mod.ccall('Z3_get_decl_rational_parameter', 'string', ['number', 'number', 'number'], [c, d, idx]);\n            },\n            app_to_ast: Mod._Z3_app_to_ast,\n            get_app_decl: Mod._Z3_get_app_decl,\n            get_app_num_args: Mod._Z3_get_app_num_args,\n            get_app_arg: Mod._Z3_get_app_arg,\n            is_eq_ast: function (c, t1, t2) {\n                return Mod.ccall('Z3_is_eq_ast', 'boolean', ['number', 'number', 'number'], [c, t1, t2]);\n            },\n            get_ast_id: Mod._Z3_get_ast_id,\n            get_ast_hash: Mod._Z3_get_ast_hash,\n            get_sort: Mod._Z3_get_sort,\n            is_well_sorted: function (c, t) {\n                return Mod.ccall('Z3_is_well_sorted', 'boolean', ['number', 'number'], [c, t]);\n            },\n            get_bool_value: Mod._Z3_get_bool_value,\n            get_ast_kind: Mod._Z3_get_ast_kind,\n            is_app: function (c, a) {\n                return Mod.ccall('Z3_is_app', 'boolean', ['number', 'number'], [c, a]);\n            },\n            is_numeral_ast: function (c, a) {\n                return Mod.ccall('Z3_is_numeral_ast', 'boolean', ['number', 'number'], [c, a]);\n            },\n            is_algebraic_number: function (c, a) {\n                return Mod.ccall('Z3_is_algebraic_number', 'boolean', ['number', 'number'], [c, a]);\n            },\n            to_app: Mod._Z3_to_app,\n            to_func_decl: Mod._Z3_to_func_decl,\n            get_numeral_string: function (c, a) {\n                return Mod.ccall('Z3_get_numeral_string', 'string', ['number', 'number'], [c, a]);\n            },\n            get_numeral_binary_string: function (c, a) {\n                return Mod.ccall('Z3_get_numeral_binary_string', 'string', ['number', 'number'], [c, a]);\n            },\n            get_numeral_decimal_string: function (c, a, precision) {\n                return Mod.ccall('Z3_get_numeral_decimal_string', 'string', ['number', 'number', 'number'], [c, a, precision]);\n            },\n            get_numeral_double: Mod._Z3_get_numeral_double,\n            get_numerator: Mod._Z3_get_numerator,\n            get_denominator: Mod._Z3_get_denominator,\n            get_numeral_small: function (c, a) {\n                let ret = Mod.ccall('Z3_get_numeral_small', 'boolean', ['number', 'number', 'number', 'number'], [c, a, outAddress, outAddress + 8]);\n                if (!ret) {\n                    return null;\n                }\n                return { num: getOutInt64(0), den: getOutInt64(1) };\n            },\n            get_numeral_int: function (c, v) {\n                let ret = Mod.ccall('Z3_get_numeral_int', 'boolean', ['number', 'number', 'number'], [c, v, outAddress]);\n                if (!ret) {\n                    return null;\n                }\n                return getOutInt(0);\n            },\n            get_numeral_uint: function (c, v) {\n                let ret = Mod.ccall('Z3_get_numeral_uint', 'boolean', ['number', 'number', 'number'], [c, v, outAddress]);\n                if (!ret) {\n                    return null;\n                }\n                return getOutUint(0);\n            },\n            get_numeral_uint64: function (c, v) {\n                let ret = Mod.ccall('Z3_get_numeral_uint64', 'boolean', ['number', 'number', 'number'], [c, v, outAddress]);\n                if (!ret) {\n                    return null;\n                }\n                return getOutUint64(0);\n            },\n            get_numeral_int64: function (c, v) {\n                let ret = Mod.ccall('Z3_get_numeral_int64', 'boolean', ['number', 'number', 'number'], [c, v, outAddress]);\n                if (!ret) {\n                    return null;\n                }\n                return getOutInt64(0);\n            },\n            get_numeral_rational_int64: function (c, v) {\n                let ret = Mod.ccall('Z3_get_numeral_rational_int64', 'boolean', ['number', 'number', 'number', 'number'], [c, v, outAddress, outAddress + 8]);\n                if (!ret) {\n                    return null;\n                }\n                return { num: getOutInt64(0), den: getOutInt64(1) };\n            },\n            get_algebraic_number_lower: Mod._Z3_get_algebraic_number_lower,\n            get_algebraic_number_upper: Mod._Z3_get_algebraic_number_upper,\n            pattern_to_ast: Mod._Z3_pattern_to_ast,\n            get_pattern_num_terms: Mod._Z3_get_pattern_num_terms,\n            get_pattern: Mod._Z3_get_pattern,\n            get_index_value: Mod._Z3_get_index_value,\n            is_quantifier_forall: function (c, a) {\n                return Mod.ccall('Z3_is_quantifier_forall', 'boolean', ['number', 'number'], [c, a]);\n            },\n            is_quantifier_exists: function (c, a) {\n                return Mod.ccall('Z3_is_quantifier_exists', 'boolean', ['number', 'number'], [c, a]);\n            },\n            is_lambda: function (c, a) {\n                return Mod.ccall('Z3_is_lambda', 'boolean', ['number', 'number'], [c, a]);\n            },\n            get_quantifier_weight: Mod._Z3_get_quantifier_weight,\n            get_quantifier_num_patterns: Mod._Z3_get_quantifier_num_patterns,\n            get_quantifier_pattern_ast: Mod._Z3_get_quantifier_pattern_ast,\n            get_quantifier_num_no_patterns: Mod._Z3_get_quantifier_num_no_patterns,\n            get_quantifier_no_pattern_ast: Mod._Z3_get_quantifier_no_pattern_ast,\n            get_quantifier_num_bound: Mod._Z3_get_quantifier_num_bound,\n            get_quantifier_bound_name: Mod._Z3_get_quantifier_bound_name,\n            get_quantifier_bound_sort: Mod._Z3_get_quantifier_bound_sort,\n            get_quantifier_body: Mod._Z3_get_quantifier_body,\n            simplify: function (c, a) {\n                return Mod.async_call(Mod._async_Z3_simplify, c, a);\n            },\n            simplify_ex: function (c, a, p) {\n                return Mod.async_call(Mod._async_Z3_simplify_ex, c, a, p);\n            },\n            simplify_get_help: function (c) {\n                return Mod.ccall('Z3_simplify_get_help', 'string', ['number'], [c]);\n            },\n            simplify_get_param_descrs: Mod._Z3_simplify_get_param_descrs,\n            update_term: function (c, a, args) {\n                return Mod.ccall('Z3_update_term', 'number', ['number', 'number', 'number', 'array'], [c, a, args.length, intArrayToByteArr(args)]);\n            },\n            substitute: function (c, a, from, to) {\n                if (from.length !== to.length) {\n                    throw new TypeError(`from and to must be the same length (got ${from.length} and {to.length})`);\n                }\n                return Mod.ccall('Z3_substitute', 'number', ['number', 'number', 'number', 'array', 'array'], [\n                    c,\n                    a,\n                    from.length,\n                    intArrayToByteArr(from),\n                    intArrayToByteArr(to),\n                ]);\n            },\n            substitute_vars: function (c, a, to) {\n                return Mod.ccall('Z3_substitute_vars', 'number', ['number', 'number', 'number', 'array'], [c, a, to.length, intArrayToByteArr(to)]);\n            },\n            substitute_funs: function (c, a, from, to) {\n                if (from.length !== to.length) {\n                    throw new TypeError(`from and to must be the same length (got ${from.length} and {to.length})`);\n                }\n                return Mod.ccall('Z3_substitute_funs', 'number', ['number', 'number', 'number', 'array', 'array'], [\n                    c,\n                    a,\n                    from.length,\n                    intArrayToByteArr(from),\n                    intArrayToByteArr(to),\n                ]);\n            },\n            translate: Mod._Z3_translate,\n            mk_model: Mod._Z3_mk_model,\n            model_inc_ref: Mod._Z3_model_inc_ref,\n            model_dec_ref: Mod._Z3_model_dec_ref,\n            model_eval: function (c, m, t, model_completion) {\n                let ret = Mod.ccall('Z3_model_eval', 'boolean', ['number', 'number', 'number', 'boolean', 'number'], [c, m, t, model_completion, outAddress]);\n                if (!ret) {\n                    return null;\n                }\n                return getOutUint(0);\n            },\n            model_get_const_interp: function (c, m, a) {\n                let ret = Mod.ccall('Z3_model_get_const_interp', 'number', ['number', 'number', 'number'], [c, m, a]);\n                if (ret === 0) {\n                    return null;\n                }\n                return ret;\n            },\n            model_has_interp: function (c, m, a) {\n                return Mod.ccall('Z3_model_has_interp', 'boolean', ['number', 'number', 'number'], [c, m, a]);\n            },\n            model_get_func_interp: function (c, m, f) {\n                let ret = Mod.ccall('Z3_model_get_func_interp', 'number', ['number', 'number', 'number'], [c, m, f]);\n                if (ret === 0) {\n                    return null;\n                }\n                return ret;\n            },\n            model_get_num_consts: Mod._Z3_model_get_num_consts,\n            model_get_const_decl: Mod._Z3_model_get_const_decl,\n            model_get_num_funcs: Mod._Z3_model_get_num_funcs,\n            model_get_func_decl: Mod._Z3_model_get_func_decl,\n            model_get_num_sorts: Mod._Z3_model_get_num_sorts,\n            model_get_sort: Mod._Z3_model_get_sort,\n            model_get_sort_universe: Mod._Z3_model_get_sort_universe,\n            model_translate: Mod._Z3_model_translate,\n            is_as_array: function (c, a) {\n                return Mod.ccall('Z3_is_as_array', 'boolean', ['number', 'number'], [c, a]);\n            },\n            get_as_array_func_decl: Mod._Z3_get_as_array_func_decl,\n            add_func_interp: Mod._Z3_add_func_interp,\n            add_const_interp: Mod._Z3_add_const_interp,\n            func_interp_inc_ref: Mod._Z3_func_interp_inc_ref,\n            func_interp_dec_ref: Mod._Z3_func_interp_dec_ref,\n            func_interp_get_num_entries: Mod._Z3_func_interp_get_num_entries,\n            func_interp_get_entry: Mod._Z3_func_interp_get_entry,\n            func_interp_get_else: Mod._Z3_func_interp_get_else,\n            func_interp_set_else: Mod._Z3_func_interp_set_else,\n            func_interp_get_arity: Mod._Z3_func_interp_get_arity,\n            func_interp_add_entry: Mod._Z3_func_interp_add_entry,\n            func_entry_inc_ref: Mod._Z3_func_entry_inc_ref,\n            func_entry_dec_ref: Mod._Z3_func_entry_dec_ref,\n            func_entry_get_value: Mod._Z3_func_entry_get_value,\n            func_entry_get_num_args: Mod._Z3_func_entry_get_num_args,\n            func_entry_get_arg: Mod._Z3_func_entry_get_arg,\n            open_log: function (filename) {\n                return Mod.ccall('Z3_open_log', 'boolean', ['string'], [filename]);\n            },\n            append_log: function (string) {\n                return Mod.ccall('Z3_append_log', 'void', ['string'], [string]);\n            },\n            close_log: Mod._Z3_close_log,\n            toggle_warning_messages: Mod._Z3_toggle_warning_messages,\n            set_ast_print_mode: Mod._Z3_set_ast_print_mode,\n            ast_to_string: function (c, a) {\n                return Mod.ccall('Z3_ast_to_string', 'string', ['number', 'number'], [c, a]);\n            },\n            pattern_to_string: function (c, p) {\n                return Mod.ccall('Z3_pattern_to_string', 'string', ['number', 'number'], [c, p]);\n            },\n            sort_to_string: function (c, s) {\n                return Mod.ccall('Z3_sort_to_string', 'string', ['number', 'number'], [c, s]);\n            },\n            func_decl_to_string: function (c, d) {\n                return Mod.ccall('Z3_func_decl_to_string', 'string', ['number', 'number'], [c, d]);\n            },\n            model_to_string: function (c, m) {\n                return Mod.ccall('Z3_model_to_string', 'string', ['number', 'number'], [c, m]);\n            },\n            benchmark_to_smtlib_string: function (c, name, logic, status, attributes, assumptions, formula) {\n                return Mod.ccall('Z3_benchmark_to_smtlib_string', 'string', [\n                    'number',\n                    'string',\n                    'string',\n                    'string',\n                    'string',\n                    'number',\n                    'array',\n                    'number',\n                ], [\n                    c,\n                    name,\n                    logic,\n                    status,\n                    attributes,\n                    assumptions.length,\n                    intArrayToByteArr(assumptions),\n                    formula,\n                ]);\n            },\n            parse_smtlib2_string: function (c, str, sort_names, sorts, decl_names, decls) {\n                if (sort_names.length !== sorts.length) {\n                    throw new TypeError(`sort_names and sorts must be the same length (got ${sort_names.length} and {sorts.length})`);\n                }\n                if (decl_names.length !== decls.length) {\n                    throw new TypeError(`decl_names and decls must be the same length (got ${decl_names.length} and {decls.length})`);\n                }\n                return Mod.ccall('Z3_parse_smtlib2_string', 'number', [\n                    'number',\n                    'string',\n                    'number',\n                    'array',\n                    'array',\n                    'number',\n                    'array',\n                    'array',\n                ], [\n                    c,\n                    str,\n                    sort_names.length,\n                    intArrayToByteArr(sort_names),\n                    intArrayToByteArr(sorts),\n                    decl_names.length,\n                    intArrayToByteArr(decl_names),\n                    intArrayToByteArr(decls),\n                ]);\n            },\n            parse_smtlib2_file: function (c, file_name, sort_names, sorts, decl_names, decls) {\n                if (sort_names.length !== sorts.length) {\n                    throw new TypeError(`sort_names and sorts must be the same length (got ${sort_names.length} and {sorts.length})`);\n                }\n                if (decl_names.length !== decls.length) {\n                    throw new TypeError(`decl_names and decls must be the same length (got ${decl_names.length} and {decls.length})`);\n                }\n                return Mod.ccall('Z3_parse_smtlib2_file', 'number', [\n                    'number',\n                    'string',\n                    'number',\n                    'array',\n                    'array',\n                    'number',\n                    'array',\n                    'array',\n                ], [\n                    c,\n                    file_name,\n                    sort_names.length,\n                    intArrayToByteArr(sort_names),\n                    intArrayToByteArr(sorts),\n                    decl_names.length,\n                    intArrayToByteArr(decl_names),\n                    intArrayToByteArr(decls),\n                ]);\n            },\n            eval_smtlib2_string: async function (UNNAMED, str) {\n                return await Mod.async_call(() => Mod.ccall('async_Z3_eval_smtlib2_string', 'string', ['number', 'string'], [UNNAMED, str]));\n            },\n            mk_parser_context: Mod._Z3_mk_parser_context,\n            parser_context_inc_ref: Mod._Z3_parser_context_inc_ref,\n            parser_context_dec_ref: Mod._Z3_parser_context_dec_ref,\n            parser_context_add_sort: Mod._Z3_parser_context_add_sort,\n            parser_context_add_decl: Mod._Z3_parser_context_add_decl,\n            parser_context_from_string: function (c, pc, s) {\n                return Mod.ccall('Z3_parser_context_from_string', 'number', ['number', 'number', 'string'], [c, pc, s]);\n            },\n            get_error_code: Mod._Z3_get_error_code,\n            set_error: Mod._Z3_set_error,\n            get_error_msg: function (c, err) {\n                return Mod.ccall('Z3_get_error_msg', 'string', ['number', 'number'], [c, err]);\n            },\n            get_version: function () {\n                let ret = Mod.ccall('Z3_get_version', 'void', ['number', 'number', 'number', 'number'], [outAddress, outAddress + 4, outAddress + 8, outAddress + 12]);\n                return {\n                    major: getOutUint(0),\n                    minor: getOutUint(1),\n                    build_number: getOutUint(2),\n                    revision_number: getOutUint(3),\n                };\n            },\n            get_full_version: function () {\n                return Mod.ccall('Z3_get_full_version', 'string', [], []);\n            },\n            enable_trace: function (tag) {\n                return Mod.ccall('Z3_enable_trace', 'void', ['string'], [tag]);\n            },\n            disable_trace: function (tag) {\n                return Mod.ccall('Z3_disable_trace', 'void', ['string'], [tag]);\n            },\n            reset_memory: Mod._Z3_reset_memory,\n            finalize_memory: Mod._Z3_finalize_memory,\n            mk_goal: Mod._Z3_mk_goal,\n            goal_inc_ref: Mod._Z3_goal_inc_ref,\n            goal_dec_ref: Mod._Z3_goal_dec_ref,\n            goal_precision: Mod._Z3_goal_precision,\n            goal_assert: Mod._Z3_goal_assert,\n            goal_inconsistent: function (c, g) {\n                return Mod.ccall('Z3_goal_inconsistent', 'boolean', ['number', 'number'], [c, g]);\n            },\n            goal_depth: Mod._Z3_goal_depth,\n            goal_reset: Mod._Z3_goal_reset,\n            goal_size: Mod._Z3_goal_size,\n            goal_formula: Mod._Z3_goal_formula,\n            goal_num_exprs: Mod._Z3_goal_num_exprs,\n            goal_is_decided_sat: function (c, g) {\n                return Mod.ccall('Z3_goal_is_decided_sat', 'boolean', ['number', 'number'], [c, g]);\n            },\n            goal_is_decided_unsat: function (c, g) {\n                return Mod.ccall('Z3_goal_is_decided_unsat', 'boolean', ['number', 'number'], [c, g]);\n            },\n            goal_translate: Mod._Z3_goal_translate,\n            goal_convert_model: Mod._Z3_goal_convert_model,\n            goal_to_string: function (c, g) {\n                return Mod.ccall('Z3_goal_to_string', 'string', ['number', 'number'], [c, g]);\n            },\n            goal_to_dimacs_string: function (c, g, include_names) {\n                return Mod.ccall('Z3_goal_to_dimacs_string', 'string', ['number', 'number', 'boolean'], [c, g, include_names]);\n            },\n            mk_tactic: function (c, name) {\n                return Mod.ccall('Z3_mk_tactic', 'number', ['number', 'string'], [c, name]);\n            },\n            tactic_inc_ref: Mod._Z3_tactic_inc_ref,\n            tactic_dec_ref: Mod._Z3_tactic_dec_ref,\n            mk_probe: function (c, name) {\n                return Mod.ccall('Z3_mk_probe', 'number', ['number', 'string'], [c, name]);\n            },\n            probe_inc_ref: Mod._Z3_probe_inc_ref,\n            probe_dec_ref: Mod._Z3_probe_dec_ref,\n            tactic_and_then: Mod._Z3_tactic_and_then,\n            tactic_or_else: Mod._Z3_tactic_or_else,\n            tactic_par_or: function (c, ts) {\n                return Mod.ccall('Z3_tactic_par_or', 'number', ['number', 'number', 'array'], [c, ts.length, intArrayToByteArr(ts)]);\n            },\n            tactic_par_and_then: Mod._Z3_tactic_par_and_then,\n            tactic_try_for: Mod._Z3_tactic_try_for,\n            tactic_when: Mod._Z3_tactic_when,\n            tactic_cond: Mod._Z3_tactic_cond,\n            tactic_repeat: Mod._Z3_tactic_repeat,\n            tactic_skip: Mod._Z3_tactic_skip,\n            tactic_fail: Mod._Z3_tactic_fail,\n            tactic_fail_if: Mod._Z3_tactic_fail_if,\n            tactic_fail_if_not_decided: Mod._Z3_tactic_fail_if_not_decided,\n            tactic_using_params: Mod._Z3_tactic_using_params,\n            probe_const: Mod._Z3_probe_const,\n            probe_lt: Mod._Z3_probe_lt,\n            probe_gt: Mod._Z3_probe_gt,\n            probe_le: Mod._Z3_probe_le,\n            probe_ge: Mod._Z3_probe_ge,\n            probe_eq: Mod._Z3_probe_eq,\n            probe_and: Mod._Z3_probe_and,\n            probe_or: Mod._Z3_probe_or,\n            probe_not: Mod._Z3_probe_not,\n            get_num_tactics: Mod._Z3_get_num_tactics,\n            get_tactic_name: function (c, i) {\n                return Mod.ccall('Z3_get_tactic_name', 'string', ['number', 'number'], [c, i]);\n            },\n            get_num_probes: Mod._Z3_get_num_probes,\n            get_probe_name: function (c, i) {\n                return Mod.ccall('Z3_get_probe_name', 'string', ['number', 'number'], [c, i]);\n            },\n            tactic_get_help: function (c, t) {\n                return Mod.ccall('Z3_tactic_get_help', 'string', ['number', 'number'], [c, t]);\n            },\n            tactic_get_param_descrs: Mod._Z3_tactic_get_param_descrs,\n            tactic_get_descr: function (c, name) {\n                return Mod.ccall('Z3_tactic_get_descr', 'string', ['number', 'string'], [c, name]);\n            },\n            probe_get_descr: function (c, name) {\n                return Mod.ccall('Z3_probe_get_descr', 'string', ['number', 'string'], [c, name]);\n            },\n            probe_apply: Mod._Z3_probe_apply,\n            tactic_apply: function (c, t, g) {\n                return Mod.async_call(Mod._async_Z3_tactic_apply, c, t, g);\n            },\n            tactic_apply_ex: function (c, t, g, p) {\n                return Mod.async_call(Mod._async_Z3_tactic_apply_ex, c, t, g, p);\n            },\n            apply_result_inc_ref: Mod._Z3_apply_result_inc_ref,\n            apply_result_dec_ref: Mod._Z3_apply_result_dec_ref,\n            apply_result_to_string: function (c, r) {\n                return Mod.ccall('Z3_apply_result_to_string', 'string', ['number', 'number'], [c, r]);\n            },\n            apply_result_get_num_subgoals: Mod._Z3_apply_result_get_num_subgoals,\n            apply_result_get_subgoal: Mod._Z3_apply_result_get_subgoal,\n            mk_solver: Mod._Z3_mk_solver,\n            mk_simple_solver: Mod._Z3_mk_simple_solver,\n            mk_solver_for_logic: Mod._Z3_mk_solver_for_logic,\n            mk_solver_from_tactic: Mod._Z3_mk_solver_from_tactic,\n            solver_translate: Mod._Z3_solver_translate,\n            solver_import_model_converter: Mod._Z3_solver_import_model_converter,\n            solver_get_help: function (c, s) {\n                return Mod.ccall('Z3_solver_get_help', 'string', ['number', 'number'], [c, s]);\n            },\n            solver_get_param_descrs: Mod._Z3_solver_get_param_descrs,\n            solver_set_params: Mod._Z3_solver_set_params,\n            solver_inc_ref: Mod._Z3_solver_inc_ref,\n            solver_dec_ref: Mod._Z3_solver_dec_ref,\n            solver_interrupt: Mod._Z3_solver_interrupt,\n            solver_push: Mod._Z3_solver_push,\n            solver_pop: Mod._Z3_solver_pop,\n            solver_reset: Mod._Z3_solver_reset,\n            solver_get_num_scopes: Mod._Z3_solver_get_num_scopes,\n            solver_assert: Mod._Z3_solver_assert,\n            solver_assert_and_track: Mod._Z3_solver_assert_and_track,\n            solver_from_file: function (c, s, file_name) {\n                return Mod.ccall('Z3_solver_from_file', 'void', ['number', 'number', 'string'], [c, s, file_name]);\n            },\n            solver_from_string: function (c, s, file_name) {\n                return Mod.ccall('Z3_solver_from_string', 'void', ['number', 'number', 'string'], [c, s, file_name]);\n            },\n            solver_get_assertions: Mod._Z3_solver_get_assertions,\n            solver_get_units: Mod._Z3_solver_get_units,\n            solver_get_trail: Mod._Z3_solver_get_trail,\n            solver_get_non_units: Mod._Z3_solver_get_non_units,\n            solver_get_levels: function (c, s, literals, levels) {\n                return Mod.ccall('Z3_solver_get_levels', 'void', ['number', 'number', 'number', 'number', 'array'], [\n                    c,\n                    s,\n                    literals,\n                    levels.length,\n                    intArrayToByteArr(levels),\n                ]);\n            },\n            solver_next_split: Mod._Z3_solver_next_split,\n            solver_propagate_declare: function (c, name, domain, range) {\n                return Mod.ccall('Z3_solver_propagate_declare', 'number', ['number', 'number', 'number', 'array', 'number'], [\n                    c,\n                    name,\n                    domain.length,\n                    intArrayToByteArr(domain),\n                    range,\n                ]);\n            },\n            solver_propagate_register: Mod._Z3_solver_propagate_register,\n            solver_propagate_register_cb: Mod._Z3_solver_propagate_register_cb,\n            solver_propagate_consequence: function (c, UNNAMED, fixed, eq_lhs, eq_rhs, conseq) {\n                if (eq_lhs.length !== eq_rhs.length) {\n                    throw new TypeError(`eq_lhs and eq_rhs must be the same length (got ${eq_lhs.length} and {eq_rhs.length})`);\n                }\n                return Mod.ccall('Z3_solver_propagate_consequence', 'void', [\n                    'number',\n                    'number',\n                    'number',\n                    'array',\n                    'number',\n                    'array',\n                    'array',\n                    'number',\n                ], [\n                    c,\n                    UNNAMED,\n                    fixed.length,\n                    intArrayToByteArr(fixed),\n                    eq_lhs.length,\n                    intArrayToByteArr(eq_lhs),\n                    intArrayToByteArr(eq_rhs),\n                    conseq,\n                ]);\n            },\n            solver_check: function (c, s) {\n                return Mod.async_call(Mod._async_Z3_solver_check, c, s);\n            },\n            solver_check_assumptions: async function (c, s, assumptions) {\n                return await Mod.async_call(() => Mod.ccall('async_Z3_solver_check_assumptions', 'number', ['number', 'number', 'number', 'array'], [\n                    c,\n                    s,\n                    assumptions.length,\n                    intArrayToByteArr(assumptions),\n                ]));\n            },\n            get_implied_equalities: function (c, s, terms) {\n                let outArray_class_ids = Mod._malloc(4 * terms.length);\n                try {\n                    let ret = Mod.ccall('Z3_get_implied_equalities', 'number', ['number', 'number', 'number', 'array', 'number'], [\n                        c,\n                        s,\n                        terms.length,\n                        intArrayToByteArr(terms),\n                        outArray_class_ids,\n                    ]);\n                    return {\n                        rv: ret,\n                        class_ids: readUintArray(outArray_class_ids, terms.length),\n                    };\n                }\n                finally {\n                    Mod._free(outArray_class_ids);\n                }\n            },\n            solver_get_consequences: function (c, s, assumptions, variables, consequences) {\n                return Mod.async_call(Mod._async_Z3_solver_get_consequences, c, s, assumptions, variables, consequences);\n            },\n            solver_cube: function (c, s, vars, backtrack_level) {\n                return Mod.async_call(Mod._async_Z3_solver_cube, c, s, vars, backtrack_level);\n            },\n            solver_get_model: Mod._Z3_solver_get_model,\n            solver_get_proof: Mod._Z3_solver_get_proof,\n            solver_get_unsat_core: Mod._Z3_solver_get_unsat_core,\n            solver_get_reason_unknown: function (c, s) {\n                return Mod.ccall('Z3_solver_get_reason_unknown', 'string', ['number', 'number'], [c, s]);\n            },\n            solver_get_statistics: Mod._Z3_solver_get_statistics,\n            solver_to_string: function (c, s) {\n                return Mod.ccall('Z3_solver_to_string', 'string', ['number', 'number'], [c, s]);\n            },\n            solver_to_dimacs_string: function (c, s, include_names) {\n                return Mod.ccall('Z3_solver_to_dimacs_string', 'string', ['number', 'number', 'boolean'], [c, s, include_names]);\n            },\n            stats_to_string: function (c, s) {\n                return Mod.ccall('Z3_stats_to_string', 'string', ['number', 'number'], [c, s]);\n            },\n            stats_inc_ref: Mod._Z3_stats_inc_ref,\n            stats_dec_ref: Mod._Z3_stats_dec_ref,\n            stats_size: Mod._Z3_stats_size,\n            stats_get_key: function (c, s, idx) {\n                return Mod.ccall('Z3_stats_get_key', 'string', ['number', 'number', 'number'], [c, s, idx]);\n            },\n            stats_is_uint: function (c, s, idx) {\n                return Mod.ccall('Z3_stats_is_uint', 'boolean', ['number', 'number', 'number'], [c, s, idx]);\n            },\n            stats_is_double: function (c, s, idx) {\n                return Mod.ccall('Z3_stats_is_double', 'boolean', ['number', 'number', 'number'], [c, s, idx]);\n            },\n            stats_get_uint_value: Mod._Z3_stats_get_uint_value,\n            stats_get_double_value: Mod._Z3_stats_get_double_value,\n            get_estimated_alloc_size: Mod._Z3_get_estimated_alloc_size,\n            algebraic_is_value: function (c, a) {\n                return Mod.ccall('Z3_algebraic_is_value', 'boolean', ['number', 'number'], [c, a]);\n            },\n            algebraic_is_pos: function (c, a) {\n                return Mod.ccall('Z3_algebraic_is_pos', 'boolean', ['number', 'number'], [c, a]);\n            },\n            algebraic_is_neg: function (c, a) {\n                return Mod.ccall('Z3_algebraic_is_neg', 'boolean', ['number', 'number'], [c, a]);\n            },\n            algebraic_is_zero: function (c, a) {\n                return Mod.ccall('Z3_algebraic_is_zero', 'boolean', ['number', 'number'], [c, a]);\n            },\n            algebraic_sign: Mod._Z3_algebraic_sign,\n            algebraic_add: Mod._Z3_algebraic_add,\n            algebraic_sub: Mod._Z3_algebraic_sub,\n            algebraic_mul: Mod._Z3_algebraic_mul,\n            algebraic_div: Mod._Z3_algebraic_div,\n            algebraic_root: Mod._Z3_algebraic_root,\n            algebraic_power: Mod._Z3_algebraic_power,\n            algebraic_lt: function (c, a, b) {\n                return Mod.ccall('Z3_algebraic_lt', 'boolean', ['number', 'number', 'number'], [c, a, b]);\n            },\n            algebraic_gt: function (c, a, b) {\n                return Mod.ccall('Z3_algebraic_gt', 'boolean', ['number', 'number', 'number'], [c, a, b]);\n            },\n            algebraic_le: function (c, a, b) {\n                return Mod.ccall('Z3_algebraic_le', 'boolean', ['number', 'number', 'number'], [c, a, b]);\n            },\n            algebraic_ge: function (c, a, b) {\n                return Mod.ccall('Z3_algebraic_ge', 'boolean', ['number', 'number', 'number'], [c, a, b]);\n            },\n            algebraic_eq: function (c, a, b) {\n                return Mod.ccall('Z3_algebraic_eq', 'boolean', ['number', 'number', 'number'], [c, a, b]);\n            },\n            algebraic_neq: function (c, a, b) {\n                return Mod.ccall('Z3_algebraic_neq', 'boolean', ['number', 'number', 'number'], [c, a, b]);\n            },\n            algebraic_roots: async function (c, p, a) {\n                return await Mod.async_call(() => Mod.ccall('async_Z3_algebraic_roots', 'number', ['number', 'number', 'number', 'array'], [c, p, a.length, intArrayToByteArr(a)]));\n            },\n            algebraic_eval: async function (c, p, a) {\n                return await Mod.async_call(() => Mod.ccall('async_Z3_algebraic_eval', 'number', ['number', 'number', 'number', 'array'], [c, p, a.length, intArrayToByteArr(a)]));\n            },\n            algebraic_get_poly: Mod._Z3_algebraic_get_poly,\n            algebraic_get_i: Mod._Z3_algebraic_get_i,\n            mk_ast_vector: Mod._Z3_mk_ast_vector,\n            ast_vector_inc_ref: Mod._Z3_ast_vector_inc_ref,\n            ast_vector_dec_ref: Mod._Z3_ast_vector_dec_ref,\n            ast_vector_size: Mod._Z3_ast_vector_size,\n            ast_vector_get: Mod._Z3_ast_vector_get,\n            ast_vector_set: Mod._Z3_ast_vector_set,\n            ast_vector_resize: Mod._Z3_ast_vector_resize,\n            ast_vector_push: Mod._Z3_ast_vector_push,\n            ast_vector_translate: Mod._Z3_ast_vector_translate,\n            ast_vector_to_string: function (c, v) {\n                return Mod.ccall('Z3_ast_vector_to_string', 'string', ['number', 'number'], [c, v]);\n            },\n            mk_ast_map: Mod._Z3_mk_ast_map,\n            ast_map_inc_ref: Mod._Z3_ast_map_inc_ref,\n            ast_map_dec_ref: Mod._Z3_ast_map_dec_ref,\n            ast_map_contains: function (c, m, k) {\n                return Mod.ccall('Z3_ast_map_contains', 'boolean', ['number', 'number', 'number'], [c, m, k]);\n            },\n            ast_map_find: Mod._Z3_ast_map_find,\n            ast_map_insert: Mod._Z3_ast_map_insert,\n            ast_map_erase: Mod._Z3_ast_map_erase,\n            ast_map_reset: Mod._Z3_ast_map_reset,\n            ast_map_size: Mod._Z3_ast_map_size,\n            ast_map_keys: Mod._Z3_ast_map_keys,\n            ast_map_to_string: function (c, m) {\n                return Mod.ccall('Z3_ast_map_to_string', 'string', ['number', 'number'], [c, m]);\n            },\n            mk_fixedpoint: Mod._Z3_mk_fixedpoint,\n            fixedpoint_inc_ref: Mod._Z3_fixedpoint_inc_ref,\n            fixedpoint_dec_ref: Mod._Z3_fixedpoint_dec_ref,\n            fixedpoint_add_rule: Mod._Z3_fixedpoint_add_rule,\n            fixedpoint_add_fact: function (c, d, r, args) {\n                return Mod.ccall('Z3_fixedpoint_add_fact', 'void', ['number', 'number', 'number', 'number', 'array'], [c, d, r, args.length, intArrayToByteArr(args)]);\n            },\n            fixedpoint_assert: Mod._Z3_fixedpoint_assert,\n            fixedpoint_query: function (c, d, query) {\n                return Mod.async_call(Mod._async_Z3_fixedpoint_query, c, d, query);\n            },\n            fixedpoint_query_relations: async function (c, d, relations) {\n                return await Mod.async_call(() => Mod.ccall('async_Z3_fixedpoint_query_relations', 'number', ['number', 'number', 'number', 'array'], [\n                    c,\n                    d,\n                    relations.length,\n                    intArrayToByteArr(relations),\n                ]));\n            },\n            fixedpoint_get_answer: Mod._Z3_fixedpoint_get_answer,\n            fixedpoint_get_reason_unknown: function (c, d) {\n                return Mod.ccall('Z3_fixedpoint_get_reason_unknown', 'string', ['number', 'number'], [c, d]);\n            },\n            fixedpoint_update_rule: Mod._Z3_fixedpoint_update_rule,\n            fixedpoint_get_num_levels: Mod._Z3_fixedpoint_get_num_levels,\n            fixedpoint_get_cover_delta: Mod._Z3_fixedpoint_get_cover_delta,\n            fixedpoint_add_cover: Mod._Z3_fixedpoint_add_cover,\n            fixedpoint_get_statistics: Mod._Z3_fixedpoint_get_statistics,\n            fixedpoint_register_relation: Mod._Z3_fixedpoint_register_relation,\n            fixedpoint_set_predicate_representation: function (c, d, f, relation_kinds) {\n                return Mod.ccall('Z3_fixedpoint_set_predicate_representation', 'void', ['number', 'number', 'number', 'number', 'array'], [\n                    c,\n                    d,\n                    f,\n                    relation_kinds.length,\n                    intArrayToByteArr(relation_kinds),\n                ]);\n            },\n            fixedpoint_get_rules: Mod._Z3_fixedpoint_get_rules,\n            fixedpoint_get_assertions: Mod._Z3_fixedpoint_get_assertions,\n            fixedpoint_set_params: Mod._Z3_fixedpoint_set_params,\n            fixedpoint_get_help: function (c, f) {\n                return Mod.ccall('Z3_fixedpoint_get_help', 'string', ['number', 'number'], [c, f]);\n            },\n            fixedpoint_get_param_descrs: Mod._Z3_fixedpoint_get_param_descrs,\n            fixedpoint_to_string: function (c, f, queries) {\n                return Mod.ccall('Z3_fixedpoint_to_string', 'string', ['number', 'number', 'number', 'array'], [\n                    c,\n                    f,\n                    queries.length,\n                    intArrayToByteArr(queries),\n                ]);\n            },\n            fixedpoint_from_string: function (c, f, s) {\n                return Mod.ccall('Z3_fixedpoint_from_string', 'number', ['number', 'number', 'string'], [c, f, s]);\n            },\n            fixedpoint_from_file: function (c, f, s) {\n                return Mod.ccall('Z3_fixedpoint_from_file', 'number', ['number', 'number', 'string'], [c, f, s]);\n            },\n            mk_fpa_rounding_mode_sort: Mod._Z3_mk_fpa_rounding_mode_sort,\n            mk_fpa_round_nearest_ties_to_even: Mod._Z3_mk_fpa_round_nearest_ties_to_even,\n            mk_fpa_rne: Mod._Z3_mk_fpa_rne,\n            mk_fpa_round_nearest_ties_to_away: Mod._Z3_mk_fpa_round_nearest_ties_to_away,\n            mk_fpa_rna: Mod._Z3_mk_fpa_rna,\n            mk_fpa_round_toward_positive: Mod._Z3_mk_fpa_round_toward_positive,\n            mk_fpa_rtp: Mod._Z3_mk_fpa_rtp,\n            mk_fpa_round_toward_negative: Mod._Z3_mk_fpa_round_toward_negative,\n            mk_fpa_rtn: Mod._Z3_mk_fpa_rtn,\n            mk_fpa_round_toward_zero: Mod._Z3_mk_fpa_round_toward_zero,\n            mk_fpa_rtz: Mod._Z3_mk_fpa_rtz,\n            mk_fpa_sort: Mod._Z3_mk_fpa_sort,\n            mk_fpa_sort_half: Mod._Z3_mk_fpa_sort_half,\n            mk_fpa_sort_16: Mod._Z3_mk_fpa_sort_16,\n            mk_fpa_sort_single: Mod._Z3_mk_fpa_sort_single,\n            mk_fpa_sort_32: Mod._Z3_mk_fpa_sort_32,\n            mk_fpa_sort_double: Mod._Z3_mk_fpa_sort_double,\n            mk_fpa_sort_64: Mod._Z3_mk_fpa_sort_64,\n            mk_fpa_sort_quadruple: Mod._Z3_mk_fpa_sort_quadruple,\n            mk_fpa_sort_128: Mod._Z3_mk_fpa_sort_128,\n            mk_fpa_nan: Mod._Z3_mk_fpa_nan,\n            mk_fpa_inf: Mod._Z3_mk_fpa_inf,\n            mk_fpa_zero: Mod._Z3_mk_fpa_zero,\n            mk_fpa_fp: Mod._Z3_mk_fpa_fp,\n            mk_fpa_numeral_float: Mod._Z3_mk_fpa_numeral_float,\n            mk_fpa_numeral_double: Mod._Z3_mk_fpa_numeral_double,\n            mk_fpa_numeral_int: Mod._Z3_mk_fpa_numeral_int,\n            mk_fpa_numeral_int_uint: Mod._Z3_mk_fpa_numeral_int_uint,\n            mk_fpa_numeral_int64_uint64: Mod._Z3_mk_fpa_numeral_int64_uint64,\n            mk_fpa_abs: Mod._Z3_mk_fpa_abs,\n            mk_fpa_neg: Mod._Z3_mk_fpa_neg,\n            mk_fpa_add: Mod._Z3_mk_fpa_add,\n            mk_fpa_sub: Mod._Z3_mk_fpa_sub,\n            mk_fpa_mul: Mod._Z3_mk_fpa_mul,\n            mk_fpa_div: Mod._Z3_mk_fpa_div,\n            mk_fpa_fma: Mod._Z3_mk_fpa_fma,\n            mk_fpa_sqrt: Mod._Z3_mk_fpa_sqrt,\n            mk_fpa_rem: Mod._Z3_mk_fpa_rem,\n            mk_fpa_round_to_integral: Mod._Z3_mk_fpa_round_to_integral,\n            mk_fpa_min: Mod._Z3_mk_fpa_min,\n            mk_fpa_max: Mod._Z3_mk_fpa_max,\n            mk_fpa_leq: Mod._Z3_mk_fpa_leq,\n            mk_fpa_lt: Mod._Z3_mk_fpa_lt,\n            mk_fpa_geq: Mod._Z3_mk_fpa_geq,\n            mk_fpa_gt: Mod._Z3_mk_fpa_gt,\n            mk_fpa_eq: Mod._Z3_mk_fpa_eq,\n            mk_fpa_is_normal: Mod._Z3_mk_fpa_is_normal,\n            mk_fpa_is_subnormal: Mod._Z3_mk_fpa_is_subnormal,\n            mk_fpa_is_zero: Mod._Z3_mk_fpa_is_zero,\n            mk_fpa_is_infinite: Mod._Z3_mk_fpa_is_infinite,\n            mk_fpa_is_nan: Mod._Z3_mk_fpa_is_nan,\n            mk_fpa_is_negative: Mod._Z3_mk_fpa_is_negative,\n            mk_fpa_is_positive: Mod._Z3_mk_fpa_is_positive,\n            mk_fpa_to_fp_bv: Mod._Z3_mk_fpa_to_fp_bv,\n            mk_fpa_to_fp_float: Mod._Z3_mk_fpa_to_fp_float,\n            mk_fpa_to_fp_real: Mod._Z3_mk_fpa_to_fp_real,\n            mk_fpa_to_fp_signed: Mod._Z3_mk_fpa_to_fp_signed,\n            mk_fpa_to_fp_unsigned: Mod._Z3_mk_fpa_to_fp_unsigned,\n            mk_fpa_to_ubv: Mod._Z3_mk_fpa_to_ubv,\n            mk_fpa_to_sbv: Mod._Z3_mk_fpa_to_sbv,\n            mk_fpa_to_real: Mod._Z3_mk_fpa_to_real,\n            fpa_get_ebits: Mod._Z3_fpa_get_ebits,\n            fpa_get_sbits: Mod._Z3_fpa_get_sbits,\n            fpa_is_numeral_nan: function (c, t) {\n                return Mod.ccall('Z3_fpa_is_numeral_nan', 'boolean', ['number', 'number'], [c, t]);\n            },\n            fpa_is_numeral_inf: function (c, t) {\n                return Mod.ccall('Z3_fpa_is_numeral_inf', 'boolean', ['number', 'number'], [c, t]);\n            },\n            fpa_is_numeral_zero: function (c, t) {\n                return Mod.ccall('Z3_fpa_is_numeral_zero', 'boolean', ['number', 'number'], [c, t]);\n            },\n            fpa_is_numeral_normal: function (c, t) {\n                return Mod.ccall('Z3_fpa_is_numeral_normal', 'boolean', ['number', 'number'], [c, t]);\n            },\n            fpa_is_numeral_subnormal: function (c, t) {\n                return Mod.ccall('Z3_fpa_is_numeral_subnormal', 'boolean', ['number', 'number'], [c, t]);\n            },\n            fpa_is_numeral_positive: function (c, t) {\n                return Mod.ccall('Z3_fpa_is_numeral_positive', 'boolean', ['number', 'number'], [c, t]);\n            },\n            fpa_is_numeral_negative: function (c, t) {\n                return Mod.ccall('Z3_fpa_is_numeral_negative', 'boolean', ['number', 'number'], [c, t]);\n            },\n            fpa_get_numeral_sign_bv: Mod._Z3_fpa_get_numeral_sign_bv,\n            fpa_get_numeral_significand_bv: Mod._Z3_fpa_get_numeral_significand_bv,\n            fpa_get_numeral_sign: function (c, t) {\n                let ret = Mod.ccall('Z3_fpa_get_numeral_sign', 'boolean', ['number', 'number', 'number'], [c, t, outAddress]);\n                if (!ret) {\n                    return null;\n                }\n                return getOutInt(0);\n            },\n            fpa_get_numeral_significand_string: function (c, t) {\n                return Mod.ccall('Z3_fpa_get_numeral_significand_string', 'string', ['number', 'number'], [c, t]);\n            },\n            fpa_get_numeral_significand_uint64: function (c, t) {\n                let ret = Mod.ccall('Z3_fpa_get_numeral_significand_uint64', 'boolean', ['number', 'number', 'number'], [c, t, outAddress]);\n                if (!ret) {\n                    return null;\n                }\n                return getOutUint64(0);\n            },\n            fpa_get_numeral_exponent_string: function (c, t, biased) {\n                return Mod.ccall('Z3_fpa_get_numeral_exponent_string', 'string', ['number', 'number', 'boolean'], [c, t, biased]);\n            },\n            fpa_get_numeral_exponent_int64: function (c, t, biased) {\n                let ret = Mod.ccall('Z3_fpa_get_numeral_exponent_int64', 'boolean', ['number', 'number', 'number', 'boolean'], [c, t, outAddress, biased]);\n                if (!ret) {\n                    return null;\n                }\n                return getOutInt64(0);\n            },\n            fpa_get_numeral_exponent_bv: Mod._Z3_fpa_get_numeral_exponent_bv,\n            mk_fpa_to_ieee_bv: Mod._Z3_mk_fpa_to_ieee_bv,\n            mk_fpa_to_fp_int_real: Mod._Z3_mk_fpa_to_fp_int_real,\n            mk_optimize: Mod._Z3_mk_optimize,\n            optimize_inc_ref: Mod._Z3_optimize_inc_ref,\n            optimize_dec_ref: Mod._Z3_optimize_dec_ref,\n            optimize_assert: Mod._Z3_optimize_assert,\n            optimize_assert_and_track: Mod._Z3_optimize_assert_and_track,\n            optimize_assert_soft: function (c, o, a, weight, id) {\n                return Mod.ccall('Z3_optimize_assert_soft', 'number', ['number', 'number', 'number', 'string', 'number'], [c, o, a, weight, id]);\n            },\n            optimize_maximize: Mod._Z3_optimize_maximize,\n            optimize_minimize: Mod._Z3_optimize_minimize,\n            optimize_push: Mod._Z3_optimize_push,\n            optimize_pop: Mod._Z3_optimize_pop,\n            optimize_check: async function (c, o, assumptions) {\n                return await Mod.async_call(() => Mod.ccall('async_Z3_optimize_check', 'number', ['number', 'number', 'number', 'array'], [\n                    c,\n                    o,\n                    assumptions.length,\n                    intArrayToByteArr(assumptions),\n                ]));\n            },\n            optimize_get_reason_unknown: function (c, d) {\n                return Mod.ccall('Z3_optimize_get_reason_unknown', 'string', ['number', 'number'], [c, d]);\n            },\n            optimize_get_model: Mod._Z3_optimize_get_model,\n            optimize_get_unsat_core: Mod._Z3_optimize_get_unsat_core,\n            optimize_set_params: Mod._Z3_optimize_set_params,\n            optimize_get_param_descrs: Mod._Z3_optimize_get_param_descrs,\n            optimize_get_lower: Mod._Z3_optimize_get_lower,\n            optimize_get_upper: Mod._Z3_optimize_get_upper,\n            optimize_get_lower_as_vector: Mod._Z3_optimize_get_lower_as_vector,\n            optimize_get_upper_as_vector: Mod._Z3_optimize_get_upper_as_vector,\n            optimize_to_string: function (c, o) {\n                return Mod.ccall('Z3_optimize_to_string', 'string', ['number', 'number'], [c, o]);\n            },\n            optimize_from_string: function (c, o, s) {\n                return Mod.ccall('Z3_optimize_from_string', 'void', ['number', 'number', 'string'], [c, o, s]);\n            },\n            optimize_from_file: function (c, o, s) {\n                return Mod.ccall('Z3_optimize_from_file', 'void', ['number', 'number', 'string'], [c, o, s]);\n            },\n            optimize_get_help: function (c, t) {\n                return Mod.ccall('Z3_optimize_get_help', 'string', ['number', 'number'], [c, t]);\n            },\n            optimize_get_statistics: Mod._Z3_optimize_get_statistics,\n            optimize_get_assertions: Mod._Z3_optimize_get_assertions,\n            optimize_get_objectives: Mod._Z3_optimize_get_objectives,\n            polynomial_subresultants: function (c, p, q, x) {\n                return Mod.async_call(Mod._async_Z3_polynomial_subresultants, c, p, q, x);\n            },\n            rcf_del: Mod._Z3_rcf_del,\n            rcf_mk_rational: function (c, val) {\n                return Mod.ccall('Z3_rcf_mk_rational', 'number', ['number', 'string'], [c, val]);\n            },\n            rcf_mk_small_int: Mod._Z3_rcf_mk_small_int,\n            rcf_mk_pi: Mod._Z3_rcf_mk_pi,\n            rcf_mk_e: Mod._Z3_rcf_mk_e,\n            rcf_mk_infinitesimal: Mod._Z3_rcf_mk_infinitesimal,\n            rcf_mk_roots: function (c, a) {\n                let outArray_roots = Mod._malloc(4 * a.length);\n                try {\n                    let ret = Mod.ccall('Z3_rcf_mk_roots', 'number', ['number', 'number', 'array', 'number'], [\n                        c,\n                        a.length,\n                        intArrayToByteArr(a),\n                        outArray_roots,\n                    ]);\n                    return {\n                        rv: ret,\n                        roots: readUintArray(outArray_roots, a.length),\n                    };\n                }\n                finally {\n                    Mod._free(outArray_roots);\n                }\n            },\n            rcf_add: Mod._Z3_rcf_add,\n            rcf_sub: Mod._Z3_rcf_sub,\n            rcf_mul: Mod._Z3_rcf_mul,\n            rcf_div: Mod._Z3_rcf_div,\n            rcf_neg: Mod._Z3_rcf_neg,\n            rcf_inv: Mod._Z3_rcf_inv,\n            rcf_power: Mod._Z3_rcf_power,\n            rcf_lt: function (c, a, b) {\n                return Mod.ccall('Z3_rcf_lt', 'boolean', ['number', 'number', 'number'], [c, a, b]);\n            },\n            rcf_gt: function (c, a, b) {\n                return Mod.ccall('Z3_rcf_gt', 'boolean', ['number', 'number', 'number'], [c, a, b]);\n            },\n            rcf_le: function (c, a, b) {\n                return Mod.ccall('Z3_rcf_le', 'boolean', ['number', 'number', 'number'], [c, a, b]);\n            },\n            rcf_ge: function (c, a, b) {\n                return Mod.ccall('Z3_rcf_ge', 'boolean', ['number', 'number', 'number'], [c, a, b]);\n            },\n            rcf_eq: function (c, a, b) {\n                return Mod.ccall('Z3_rcf_eq', 'boolean', ['number', 'number', 'number'], [c, a, b]);\n            },\n            rcf_neq: function (c, a, b) {\n                return Mod.ccall('Z3_rcf_neq', 'boolean', ['number', 'number', 'number'], [c, a, b]);\n            },\n            rcf_num_to_string: function (c, a, compact, html) {\n                return Mod.ccall('Z3_rcf_num_to_string', 'string', ['number', 'number', 'boolean', 'boolean'], [c, a, compact, html]);\n            },\n            rcf_num_to_decimal_string: function (c, a, prec) {\n                return Mod.ccall('Z3_rcf_num_to_decimal_string', 'string', ['number', 'number', 'number'], [c, a, prec]);\n            },\n            rcf_get_numerator_denominator: function (c, a) {\n                let ret = Mod.ccall('Z3_rcf_get_numerator_denominator', 'void', ['number', 'number', 'number', 'number'], [c, a, outAddress, outAddress + 4]);\n                return {\n                    n: getOutUint(0),\n                    d: getOutUint(1),\n                };\n            },\n            fixedpoint_query_from_lvl: function (c, d, query, lvl) {\n                return Mod.async_call(Mod._async_Z3_fixedpoint_query_from_lvl, c, d, query, lvl);\n            },\n            fixedpoint_get_ground_sat_answer: Mod._Z3_fixedpoint_get_ground_sat_answer,\n            fixedpoint_get_rules_along_trace: Mod._Z3_fixedpoint_get_rules_along_trace,\n            fixedpoint_get_rule_names_along_trace: Mod._Z3_fixedpoint_get_rule_names_along_trace,\n            fixedpoint_add_invariant: Mod._Z3_fixedpoint_add_invariant,\n            fixedpoint_get_reachable: Mod._Z3_fixedpoint_get_reachable,\n            qe_model_project: function (c, m, bound, body) {\n                return Mod.ccall('Z3_qe_model_project', 'number', ['number', 'number', 'number', 'array', 'number'], [\n                    c,\n                    m,\n                    bound.length,\n                    intArrayToByteArr(bound),\n                    body,\n                ]);\n            },\n            qe_model_project_skolem: function (c, m, bound, body, map) {\n                return Mod.ccall('Z3_qe_model_project_skolem', 'number', ['number', 'number', 'number', 'array', 'number', 'number'], [\n                    c,\n                    m,\n                    bound.length,\n                    intArrayToByteArr(bound),\n                    body,\n                    map,\n                ]);\n            },\n            model_extrapolate: Mod._Z3_model_extrapolate,\n            qe_lite: Mod._Z3_qe_lite,\n        },\n    };\n}\nexports.init = init;\n\n\n//# sourceURL=webpack:///./node_modules/z3-solver/build/low-level/wrapper.__GENERATED__.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.ts");
/******/ 	
/******/ })()
;